<!DOCTYPE html>
<html lang="en"><head>
<script src="04_convnets_1_files/libs/clipboard/clipboard.min.js"></script>
<script src="04_convnets_1_files/libs/quarto-html/tabby.min.js"></script>
<script src="04_convnets_1_files/libs/quarto-html/popper.min.js"></script>
<script src="04_convnets_1_files/libs/quarto-html/tippy.umd.min.js"></script>
<link href="04_convnets_1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="04_convnets_1_files/libs/quarto-html/light-border.css" rel="stylesheet">
<link href="04_convnets_1_files/libs/quarto-html/quarto-html.min.css" rel="stylesheet" data-mode="light">
<link href="04_convnets_1_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.3.450">

  <title>convnets_1</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="04_convnets_1_files/libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="04_convnets_1_files/libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #97947a;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #97947a;  padding-left: 4px; }
    div.sourceCode
      { color: #f8f8f2; background-color: #2b2b2b; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #f8f8f2; } /* Normal */
    code span.al { color: #dcc6e0; } /* Alert */
    code span.an { color: #d4d0ab; } /* Annotation */
    code span.at { color: #ffd700; } /* Attribute */
    code span.bn { color: #dcc6e0; } /* BaseN */
    code span.bu { color: #f5ab35; } /* BuiltIn */
    code span.cf { color: #ffa07a; } /* ControlFlow */
    code span.ch { color: #abe338; } /* Char */
    code span.cn { color: #ffa07a; } /* Constant */
    code span.co { color: #d4d0ab; } /* Comment */
    code span.cv { color: #d4d0ab; font-style: italic; } /* CommentVar */
    code span.do { color: #d4d0ab; font-style: italic; } /* Documentation */
    code span.dt { color: #dcc6e0; } /* DataType */
    code span.dv { color: #dcc6e0; } /* DecVal */
    code span.er { color: #dcc6e0; } /* Error */
    code span.ex { color: #ffd700; } /* Extension */
    code span.fl { color: #f5ab35; } /* Float */
    code span.fu { color: #ffd700; } /* Function */
    code span.im { color: #f8f8f2; } /* Import */
    code span.in { color: #d4d0ab; } /* Information */
    code span.kw { color: #ffa07a; } /* Keyword */
    code span.op { color: #00e0e0; } /* Operator */
    code span.ot { color: #ffa07a; } /* Other */
    code span.pp { color: #dcc6e0; } /* Preprocessor */
    code span.sc { color: #00e0e0; } /* SpecialChar */
    code span.ss { color: #abe338; } /* SpecialString */
    code span.st { color: #abe338; } /* String */
    code span.va { color: #f5ab35; } /* Variable */
    code span.vs { color: #abe338; } /* VerbatimString */
    code span.wa { color: #d4d0ab; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="04_convnets_1_files/libs/revealjs/dist/theme/quarto.css">
  <link href="04_convnets_1_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="04_convnets_1_files/libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="04_convnets_1_files/libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="04_convnets_1_files/libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">

  .callout {
    margin-top: 1em;
    margin-bottom: 1em;  
    border-radius: .25rem;
  }

  .callout.callout-style-simple { 
    padding: 0em 0.5em;
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
    display: flex;
  }

  .callout.callout-style-default {
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
  }

  .callout .callout-body-container {
    flex-grow: 1;
  }

  .callout.callout-style-simple .callout-body {
    font-size: 1rem;
    font-weight: 400;
  }

  .callout.callout-style-default .callout-body {
    font-size: 0.9rem;
    font-weight: 400;
  }

  .callout.callout-titled.callout-style-simple .callout-body {
    margin-top: 0.2em;
  }

  .callout:not(.callout-titled) .callout-body {
      display: flex;
  }

  .callout:not(.no-icon).callout-titled.callout-style-simple .callout-content {
    padding-left: 1.6em;
  }

  .callout.callout-titled .callout-header {
    padding-top: 0.2em;
    margin-bottom: -0.2em;
  }

  .callout.callout-titled .callout-title  p {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
  }
    
  .callout.callout-titled.callout-style-simple .callout-content  p {
    margin-top: 0;
  }

  .callout.callout-titled.callout-style-default .callout-content  p {
    margin-top: 0.7em;
  }

  .callout.callout-style-simple div.callout-title {
    border-bottom: none;
    font-size: .9rem;
    font-weight: 600;
    opacity: 75%;
  }

  .callout.callout-style-default  div.callout-title {
    border-bottom: none;
    font-weight: 600;
    opacity: 85%;
    font-size: 0.9rem;
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-default div.callout-content {
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-simple .callout-icon::before {
    height: 1rem;
    width: 1rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 1rem 1rem;
  }

  .callout.callout-style-default .callout-icon::before {
    height: 0.9rem;
    width: 0.9rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 0.9rem 0.9rem;
  }

  .callout-title {
    display: flex
  }
    
  .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  .callout.no-icon::before {
    display: none !important;
  }

  .callout.callout-titled .callout-body > .callout-content > :last-child {
    margin-bottom: 0.5rem;
  }

  .callout.callout-titled .callout-icon::before {
    margin-top: .5rem;
    padding-right: .5rem;
  }

  .callout:not(.callout-titled) .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  /* Callout Types */

  div.callout-note {
    border-left-color: #4582ec !important;
  }

  div.callout-note .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEU0lEQVRYCcVXTWhcVRQ+586kSUMMxkyaElstCto2SIhitS5Ek8xUKV2poatCcVHtUlFQk8mbaaziwpWgglJwVaquitBOfhQXFlqlzSJpFSpIYyXNjBNiTCck7x2/8/LeNDOZxDuEkgOXe++553zfefee+/OYLOXFk3+1LLrRdiO81yNqZ6K9cG0P3MeFaMIQjXssE8Z1JzLO9ls20MBZX7oG8w9GxB0goaPrW5aNMp1yOZIa7Wv6o2ykpLtmAPs/vrG14Z+6d4jpbSKuhdcSyq9wGMPXjonwmESXrriLzFGOdDBLB8Y6MNYBu0dRokSygMA/mrun8MGFN3behm6VVAwg4WR3i6FvYK1T7MHo9BK7ydH+1uurECoouk5MPRyVSBrBHMYwVobG2aOXM07sWrn5qgB60rc6mcwIDJtQrnrEr44kmy+UO9r0u9O5/YbkS9juQckLed3DyW2XV/qWBBB3ptvI8EUY3I9p/67OW+g967TNr3Sotn3IuVlfMLVnsBwH4fsnebJvyGm5GeIUA3jljERmrv49SizPYuq+z7c2H/jlGC+Ghhupn/hcapqmcudB9jwJ/3jvnvu6vu5lVzF1fXyZuZZ7U8nRmVzytvT+H3kilYvH09mLWrQdwFSsFEsxFVs5fK7A0g8gMZjbif4ACpKbjv7gNGaD8bUrlk8x+KRflttr22JEMRUbTUwwDQScyzPgedQHZT0xnx7ujw2jfVfExwYHwOsDTjLdJ2ebmeQIlJ7neo41s/DrsL3kl+W2lWvAga0tR3zueGr6GL78M3ifH0rGXrBC2aAR8uYcIA5gwV8zIE8onoh8u0Fca/ciF7j1uOzEnqcIm59sEXoGc0+z6+H45V1CvAvHcD7THztu669cnp+L0okAeIc6zjbM/24LgGM1gZk7jnRu1aQWoU9sfUOuhrmtaPIO3YY1KLLWZaEO5TKUbMY5zx8W9UJ6elpLwKXbsaZ4EFl7B4bMtDv0iRipKoDQT2sNQI9b1utXFdYisi+wzZ/ri/1m7QfDgEuvgUUEIJPq3DhX/5DWNqIXDOweC2wvIR90Oq3lDpdMIgD2r0dXvGdsEW5H6x6HLRJYU7C69VefO1x8Gde1ZFSJLfWS1jbCnhtOPxmpfv2LXOA2Xk2tvnwKKPFuZ/oRmwBwqRQDcKNeVQkYcOjtWVBuM/JuYw5b6isojIkYxyYAFn5K7ZBF10fea52y8QltAg6jnMqNHFBmGkQ1j+U43HMi2xMar1Nv0zGsf1s8nUsmUtPOOrbFIR8bHFDMB5zL13Gmr/kGlCkUzedTzzmzsaJXhYawnA3UmARpiYj5ooJZiUoxFRtK3X6pgNPv+IZVPcnwbOl6f+aBaO1CNvPW9n9LmCp01nuSaTRF2YxHqZ8DYQT6WsXT+RD6eUztwYLZ8rM+rcPxamv1VQzFUkzFXvkiVrySGQgJNvXHJAxiU3/NwiC03rSf05VBaPtu/Z7/B8Yn/w7eguloAAAAAElFTkSuQmCC');
  }

  div.callout-note.callout-style-default .callout-title {
    background-color: #dae6fb
  }

  div.callout-important {
    border-left-color: #d9534f !important;
  }

  div.callout-important .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEKklEQVRYCcVXTWhcVRS+575MJym48A+hSRFr00ySRQhURRfd2HYjk2SSTokuBCkU2o0LoSKKraKIBTcuFCoidGFD08nkBzdREbpQ1EDNIv8qSGMFUboImMSZd4/f9zJv8ibJMC8xJQfO3HPPPef7zrvvvnvviIkpC9nsw0UttFunbUhpFzFtarSd6WJkStVMw5xyVqYTvkwfzuf/5FgtkVoB0729j1rjXwThS7Vio+Mo6DNnvLfahoZ+i/o32lULuJ3NNiz7q6+pyAUkJaFF6JwaM2lUJlV0MlnQn5aTRbEu0SEqHUa0A4AdiGuB1kFXRfVyg5d87+Dg4DL6m2TLAub60ilj7A1Ec4odSAc8X95sHh7+ZRPCFo6Fnp7HfU/fBng/hi10CjCnWnJjsxvDNxWw0NfV6Rv5GgP3I3jGWXumdTD/3cbEOP2ZbOZp69yniG3FQ9z1jD7bnBu9Fc2tKGC2q+uAJOQHBDRiZX1x36o7fWBs7J9ownbtO+n0/qWkvW7UPIfc37WgT6ZGR++EOJyeQDSb9UB+DZ1G6DdLDzyS+b/kBCYGsYgJbSQHuThGKRcw5xdeQf8YdNHsc6ePXrlSYMBuSIAFTGAtQo+VuALo4BX83N190NWZWbynBjhOHsmNfFWLeL6v+ynsA58zDvvAC8j5PkbOcXCMg2PZFk3q8MjI7WAG/Dp9AwP7jdGBOOQkAvlFUB+irtm16I1Zw9YBcpGTGXYmk3kQIC/Cds55l+iMI3jqhjAuaoe+am2Jw5GT3Nbz3CkE12NavmzN5+erJW7046n/CH1RO/RVa8lBLozXk9uqykkGAyRXLWlLv5jyp4RFsG5vGVzpDLnIjTWgnRy2Rr+tDKvRc7Y8AyZq10jj8DqXdnIRNtFZb+t/ZRtXcDiVnzpqx8mPcDWxgARUqx0W1QB9MeUZiNrV4qP+Ehc+BpNgATsTX8ozYKL2NtFYAHc84fG7ndxUPr+AR/iQSns7uSUufAymwDOb2+NjK27lEFocm/EE2WpyIy/Hi66MWuMKJn8RvxIcj87IM5Vh9663ziW36kR0HNenXuxmfaD8JC7tfKbrhFr7LiZCrMjrzTeGx+PmkosrkNzW94ObzwocJ7A1HokLolY+AvkTiD/q1H0cN48c5EL8Crkttsa/AXQVDmutfyku0E7jShx49XqV3MFK8IryDhYVbj7Sj2P2eBxwcXoe8T8idsKKPRcnZw1b+slFTubwUwhktrfnAt7J++jwQtLZcm3sr9LQrjRzz6cfMv9aLvgmnAGvpoaGLxM4mAEaLV7iAzQ3oU0IvD5x9ix3yF2RAAuYAOO2f7PEFWCXZ4C9Pb2UsgDeVnFSpbFK7/IWu7TPTvBqzbGdCHOJQSxiEjt6IyZmxQyEJHv6xyQsYk//moVFsN2zP6fRImjfq7/n/wFDguUQFNEwugAAAABJRU5ErkJggg==');
  }

  div.callout-important.callout-style-default .callout-title {
    background-color: #f7dddc
  }

  div.callout-warning {
    border-left-color: #f0ad4e !important;
  }

  div.callout-warning .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAETklEQVRYCeVWW2gcVRg+58yaTUnizqbipZeX4uWhBEniBaoUX1Ioze52t7sRq6APio9V9MEaoWlVsFasRq0gltaAPuxms8lu0gcviE/FFOstVbSIxgcv6SU7EZqmdc7v9+9mJtNks51NTUH84ed889/PP+cmxP+d5FIbMJmNbpREu4WUkiTtCicKny0l1pIKmBzovF2S+hIJHX8iEu3hZJ5lNZGqyRrGSIQpq15AzF28jgpeY6yk6GVdrfFqdrD6Iw+QlB8g0YS2g7dyQmXM/IDhBhT0UCiRf59lfqmmDvzRt6kByV/m4JjtzuaujMUM2c5Z2d6JdKrRb3K2q6mA+oYVz8JnDdKPmmNthzkAk/lN63sYPgevrguc72aZX/L9C6x09GYyxBgCX4NlvyGUHOKELlm5rXeR1kchuChJt4SSwyddZRXgvwMGvYo4QSlk3/zkHD8UHxwVJA6zjZZqP8v8kK8OWLnIZtLyCAJagYC4rTGW/9Pqj92N/c+LUaAj27movwbi19tk/whRCIE7Q9vyI6yvRpftAKVTdUjOW40X3h5OXsKCdmFcx0xlLJoSuQngnrJe7Kcjm4OMq9FlC7CMmScQANuNvjfP3PjGXDBaUQmbp296S5L4DrpbrHN1T87ZVEZVCzg1FF0Ft+dKrlLukI+/c9ENo+TvlTDbYFvuKPtQ9+l052rXrgKoWkDAFnvh0wTOmYn8R5f4k/jN/fZiCM1tQx9jQQ4ANhqG4hiL0qIFTGViG9DKB7GYzgubnpofgYRwO+DFjh0Zin2m4b/97EDkXkc+f6xYAPX0KK2I/7fUQuwzuwo/L3AkcjugPNixC8cHf0FyPjWlItmLxWw4Ou9YsQCr5fijMGoD/zpdRy95HRysyXA74MWOnscpO4j2y3HAVisw85hX5+AFBRSHt4ShfLFkIMXTqyKFc46xdzQM6XbAi702a7sy04J0+feReMFKp5q9esYLCqAZYw/k14E/xcLLsFElaornTuJB0svMuJINy8xkIYuL+xPAlWRceH6+HX7THJ0djLUom46zREu7tTkxwmf/FdOZ/sh6Q8qvEAiHpm4PJ4a/doJe0gH1t+aHRgCzOvBvJedEK5OFE5jpm4AGP2a8Dxe3gGJ/pAutug9Gp6he92CsSsWBaEcxGx0FHytmIpuqGkOpldqNYQK8cSoXvd+xLxXADw0kf6UkJNFtdo5MOgaLjiQOQHcn+A6h5NuL2s0qsC2LOM75PcF3yr5STuBSAcGG+meA14K/CI21HcS4LBT6tv0QAh8Dr5l93AhZzG5ZJ4VxAqdZUEl9z7WJ4aN+svMvwHHL21UKTd1mqvChH7/Za5xzXBBKrUcB0TQ+Ulgkfbi/H/YT5EptrGzsEK7tR1B7ln9BBwckYfMiuSqklSznIuoIIOM42MQO+QnduCoFCI0bpkzjCjddHPN/F+2Yu+sd9bKNpVwHhbS3LluK/0zgfwD0xYI5dXuzlQAAAABJRU5ErkJggg==');
  }

  div.callout-warning.callout-style-default .callout-title {
    background-color: #fcefdc
  }

  div.callout-tip {
    border-left-color: #02b875 !important;
  }

  div.callout-tip .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAADr0lEQVRYCe1XTWgTQRj9ZjZV8a9SPIkKgj8I1bMHsUWrqYLVg4Ue6v9BwZOxSYsIerFao7UiUryIqJcqgtpimhbBXoSCVxUFe9CTiogUrUp2Pt+3aUI2u5vdNh4dmMzOzHvvezuz8xNFM0mjnbXaNu1MvFWRXkXEyE6aYOYJpdW4IXuA4r0fo8qqSMDBU0v1HJUgVieAXxzCsdE/YJTdFcVIZQNMyhruOMJKXYFoLfIfIvVIMWdsrd+Rpd86ZmyzzjJmLStqRn0v8lzkb4rVIXvnpScOJuAn2ACC65FkPzEdEy4TPWRLJ2h7z4cArXzzaOdKlbOvKKX25Wl00jSnrwVxAg3o4dRxhO13RBSdNvH0xSARv3adTXbBdTf64IWO2vH0LT+cv4GR1DJt+DUItaQogeBX/chhbTBxEiZ6gftlDNXTrvT7co4ub5A6gp9HIcHvzTa46OS5fBeP87Qm0fQkr4FsYgVQ7Qg+ZayaDg9jhg1GkWj8RG6lkeSacrrHgDaxdoBiZPg+NXV/KifMuB6//JmYH4CntVEHy/keA6x4h4CU5oFy8GzrBS18cLJMXcljAKB6INjWsRcuZBWVaS3GDrqB7rdapVIeA+isQ57Eev9eCqzqOa81CY05VLd6SamW2wA2H3SiTbnbSxmzfp7WtKZkqy4mdyAlGx7ennghYf8voqp9cLSgKdqNfa6RdRsAAkPwRuJZNbpByn+RrJi1RXTwdi8RQF6ymDwGMAtZ6TVE+4uoKh+MYkcLsT0Hk8eAienbiGdjJHZTpmNjlbFJNKDVAp2fJlYju6IreQxQ08UJDNYdoLSl6AadO+fFuCQqVMB1NJwPm69T04Wv5WhfcWyfXQB+wXRs1pt+nCknRa0LVzSA/2B+a9+zQJadb7IyyV24YAxKp2Jqs3emZTuNnKxsah+uabKbMk7CbTgJx/zIgQYErIeTKRQ9yD9wxVof5YolPHqaWo7TD6tJlh7jQnK5z2n3+fGdggIOx2kaa2YI9QWarc5Ce1ipNWMKeSG4DysFF52KBmTNMmn5HqCFkwy34rDg05gDwgH3bBi+sgFhN/e8QvRn8kbamCOhgrZ9GJhFDgfcMHzFb6BAtjKpFhzTjwv1KCVuxHvCbsSiEz4CANnj84cwHdFXAbAOJ4LTSAawGWFn5tDhLMYz6nWeU2wJfIhmIJBefcd/A5FWQWGgrWzyORZ3Q6HuV+Jf0Bj+BTX69fm1zWgK7By1YTXchFDORywnfQ7GpzOo6S+qECrsx2ifVQAAAABJRU5ErkJggg==');
  }

  div.callout-tip.callout-style-default .callout-title {
    background-color: #ccf1e3
  }

  div.callout-caution {
    border-left-color: #fd7e14 !important;
  }

  div.callout-caution .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAACV0lEQVRYCdVWzWoUQRCuqp2ICBLJXgITZL1EfQDBW/bkzUMUD7klD+ATSHBEfAIfQO+iXsWDxJsHL96EHAwhgzlkg8nBg25XWb0zIb0zs9muYYWkoKeru+vn664fBqElyZNuyh167NXJ8Ut8McjbmEraKHkd7uAnAFku+VWdb3reSmRV8PKSLfZ0Gjn3a6Xlcq9YGb6tADjn+lUfTXtVmaZ1KwBIvFI11rRXlWlatwIAAv2asaa9mlB9wwygiDX26qaw1yYPzFXg2N1GgG0FMF8Oj+VIx7E/03lHx8UhvYyNZLN7BwSPgekXXLribw7w5/c8EF+DBK5idvDVYtEEwMeYefjjLAdEyQ3M9nfOkgnPTEkYU+sxMq0BxNR6jExrAI31H1rzvLEfRIdgcv1XEdj6QTQAS2wtstEALLG1yEZ3QhH6oDX7ExBSFEkFINXH98NTrme5IOaaA7kIfiu2L8A3qhH9zRbukdCqdsA98TdElyeMe5BI8Rs2xHRIsoTSSVFfCFCWGPn9XHb4cdobRIWABNf0add9jakDjQJpJ1bTXOJXnnRXHRf+dNL1ZV1MBRCXhMbaHqGI1JkKIL7+i8uffuP6wVQAzO7+qVEbF6NbS0LJureYcWXUUhH66nLR5rYmva+2tjRFtojkM2aD76HEGAD3tPtKM309FJg5j/K682ywcWJ3PASCcycH/22u+Bh7Aa0ehM2Fu4z0SAE81HF9RkB21c5bEn4Dzw+/qNOyXr3DCTQDMBOdhi4nAgiFDGCinIa2owCEChUwD8qzd03PG+qdW/4fDzjUMcE1ZpIAAAAASUVORK5CYII=');
  }

  div.callout-caution.callout-style-default .callout-title {
    background-color: #ffe5d0
  }

  </style>
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  <meta name="twitter:title" content="Outrageously efficient exploratory data analysis with Apache Arrow and dplyr">
  <meta name="twitter:description" content="A 10 minute lightning talk on all things arrow + dplyr">
  <meta name="twitter:url" content="https://jthomasmock.github.io/arrow-dplyr/#/">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/jthomasmock/arrow-dplyr/master/index-img.png">
  <meta name="twitter:image:alt" content="The title slide of the presentation, with the arrow and dplyr hex logos">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:creator" content="@thomas_mock">
  <meta name="twitter:site" content="@thomas_mock">
  <meta property="og:title" content="Outrageously efficient exploratory data analysis with Apache Arrow and dplyr">
  <meta property="og:description" content="A 10 minute lightning talk on all things arrow + dplyr">
  <meta property="og:url" content="https://jthomasmock.github.io/arrow-dplyr/#/">
  <meta property="og:image" content="https://raw.githubusercontent.com/jthomasmock/arrow-dplyr/master/index-img.png">
  <meta property="og:image:alt" content="The title slide of the presentation, with the arrow and dplyr hex logos">
  <meta property="og:type" content="website">
  <meta property="og:locale" content="en_US">
</head>
<body class="quarto-dark">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block">
  <h1 class="title">Convolutional Neural Networks 1</h1>

<div class="quarto-title-authors">
</div>

</section>
<section class="slide level2">

<br>
<h2>
Data Science in Electron Microscopy
</h2>
<hr>
<h3>
Philipp Pelz
</h3>
<h3>
2024
</h3>
<p><br></p>
<h3>
&nbsp; <a href="https://github.com/ECLIPSE-Lab/SS24_DataScienceForEM">https://github.com/ECLIPSE-Lab/SS24_DataScienceForEM</a>
</h3>
</section>
<section id="intro" class="slide level2">
<h2>Intro</h2>
<ul>
<li><p>small tour of modern CNN architectures.</p></li>
<li><p>idea of deep neural networks is quite simple (stack together a bunch of layers), performance can vary wildly across architectures and hyperparameter choices.</p></li>
<li><p>The neural networks described in this chapter are the product of intuition, a few mathematical insights, and a lot of trial and error.</p></li>
<li><p>batch normalization and residual connections described in this chapter have offered two popular ideas for training and designing deep models, both of which have since also been applied to architectures beyond computer vision.</p></li>
<li><p>AlexNet (Krizhevsky et al., 2012), the first large-scale network deployed to beat conventional computer vision methods on a large-scale vision challenge;</p></li>
<li><p>the VGG network (Simonyan and Zisserman, 2014), which makes use of a number of repeating blocks of elements;</p></li>
<li><p>the network in network (NiN) that convolves whole neural networks patch-wise over inputs (Lin et al., 2013);</p></li>
<li><p>DenseNet (Huang et al., 2017) for a generalization of the residual architecture.</p></li>
</ul>
</section>
<section id="deep-convolutional-neural-networks-alexnet" class="slide level2">
<h2>Deep Convolutional Neural Networks (AlexNet)</h2>
<ul>
<li>Pre-CNNs classical pipelines looked more like this:</li>
</ul>
<ol type="1">
<li>Obtain an interesting dataset. In the early days, these datasets required expensive sensors. For instance, the <a href="https://en.wikipedia.org/wiki/Apple_QuickTake">Apple QuickTake 100</a> of 1994 sported a whopping 0.3 Megapixel (VGA) resolution, capable of storing up to 8 images, all for the price of $1,000.</li>
<li>Preprocess the dataset with hand-crafted features based on some knowledge of optics, geometry, other analytic tools, and occasionally on the serendipitous discoveries of lucky graduate students.</li>
<li>Feed the data through a standard set of feature extractors such as the SIFT (scale-invariant feature transform) :cite:<code>Lowe.2004</code>, the SURF (speeded up robust features) :cite:<code>Bay.Tuytelaars.Van-Gool.2006</code>, or any number of other hand-tuned pipelines. OpenCV still provides SIFT extractors to this day!</li>
<li>Dump the resulting representations into your favorite classifier, likely a linear model or kernel method, to train a classifier.</li>
</ol>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> d2l <span class="im">import</span> torch <span class="im">as</span> d2l</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> torch</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">from</span> torch <span class="im">import</span> nn</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="representation-learning" class="slide level2">
<h2>Representation Learning</h2>
<ul>
<li>Another way to cast the state of affairs is that the most important part of the pipeline was the representation.</li>
<li>And up until 2012 the representation was calculated mostly mechanically. In fact, engineering a new set of feature functions, improving results, and writing up the method was a prominent genre of paper.</li>
<li>SIFT :cite:<code>Lowe.2004</code>, SURF :cite:<code>Bay.Tuytelaars.Van-Gool.2006</code>, HOG (histograms of oriented gradient) :cite:<code>Dalal.Triggs.2005</code>, bags of visual words :cite:<code>Sivic.Zisserman.003</code>, and similar feature extractors ruled the roost.</li>
<li>Another group of researchers, including Yann LeCun, Geoff Hinton, Yoshua Bengio, Andrew Ng, Shun-ichi Amari, and Juergen Schmidhuber, had different plans.</li>
<li>They believed that features themselves ought to be learned. Moreover, they believed that to be reasonably complex, the features ought to be hierarchically composed with multiple jointly learned layers, each with learnable parameters.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>In the case of an image, the lowest layers might come to detect edges, colors, and textures, in analogy to how the visual system in animals processes its input. In particular, the automatic design of visual features such as those obtained by sparse coding :cite:<code>olshausen1996emergence</code> remained an open challenge until the advent of modern CNNs.</li>
<li>It was not until :citet:<code>dean2012large,le2013building</code> that the idea of generating features from image data automatically gained significant traction.</li>
<li>The first modern CNN :cite:<code>Krizhevsky.Sutskever.Hinton.2012</code>, named <em>AlexNet</em> after one of its inventors, Alex Krizhevsky, is largely an evolutionary improvement over LeNet. It achieved excellent performance in the 2012 ImageNet challenge.</li>
</ul>

<img data-src="../img/filters.png" class="r-stretch quarto-figure-center"><p class="caption">Image filters learned by the first layer of AlexNet. Reproduction courtesy of :citet:<code>Krizhevsky.Sutskever.Hinton.2012</code>.</p></section>
<section id="alexnet" class="slide level2">
<h2>AlexNet</h2>
<ul>
<li>AlexNet network showed, for the first time, that **features obtained by learning can transcend manually-designed features*</li>
<li>Note that we provide a slightly streamlined version of AlexNet removing some of the design quirks that were needed in 2012 to make the model fit on two small GPUs.</li>
</ul>

<img data-src="../img/alexnet.svg" class="r-stretch quarto-figure-center"><p class="caption">From LeNet (left) to AlexNet (right).</p></section>
<section id="architecture" class="slide level2">
<h2>Architecture</h2>
<ul>
<li>AlexNet’s first layer, the convolution window shape is <span class="math inline">\(11\times11\)</span>.</li>
<li>Since the images in ImageNet are eight times higher and wider than the MNIST images, objects in ImageNet data tend to occupy more pixels with more visual detail.</li>
<li>Consequently, a larger convolution window is needed to capture the object. The convolution window shape in the second layer is reduced to <span class="math inline">\(5\times5\)</span>, followed by <span class="math inline">\(3\times3\)</span>.</li>
<li>In addition, after the first, second, and fifth convolutional layers, the network adds max-pooling layers with a window shape of <span class="math inline">\(3\times3\)</span> and a stride of 2.</li>
<li>Moreover, AlexNet has ten times more convolution channels than LeNet.</li>
<li>After the last convolutional layer, there are two huge fully connected layerswith 4096 outputs.</li>
</ul>
</section>
<section id="activation-functions" class="slide level2">
<h2>Activation Functions</h2>
<ul>
<li>changed the sigmoid activation function –&gt; ReLU activation function.</li>
<li>ReLU activation function makes model training easier when using different parameter initialization methods. gradient of the ReLU activation function in the positive interval is always 1 (:numref:<code>subsec_activation-functions</code>).</li>
<li>if the model parameters are not properly initialized, the sigmoid function may obtain a gradient of almost 0 in the positive interval, so that the model cannot be effectively trained.</li>
</ul>
</section>
<section id="capacity-control-and-preprocessing" class="slide level2">
<h2>Capacity Control and Preprocessing</h2>
<ul>
<li>AlexNet controls the model complexity of the fully connected layer by dropout (:numref:<code>sec_dropout</code>), while LeNet only uses weight decay.</li>
<li>the training loop of AlexNet added image augmentation, such as flipping, clipping, and color changes.</li>
<li>makes the model more robust and the larger sample size effectively reduces overfitting.</li>
</ul>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">class</span> AlexNet(d2l.Classifier):</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, lr<span class="op">=</span><span class="fl">0.1</span>, num_classes<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb2-3"><a href="#cb2-3"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb2-4"><a href="#cb2-4"></a>        <span class="va">self</span>.save_hyperparameters()</span>
<span id="cb2-5"><a href="#cb2-5"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(</span>
<span id="cb2-6"><a href="#cb2-6"></a>            nn.LazyConv2d(<span class="dv">96</span>, kernel_size<span class="op">=</span><span class="dv">11</span>, stride<span class="op">=</span><span class="dv">4</span>, padding<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb2-7"><a href="#cb2-7"></a>            nn.ReLU(), nn.MaxPool2d(kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb2-8"><a href="#cb2-8"></a>            nn.LazyConv2d(<span class="dv">256</span>, kernel_size<span class="op">=</span><span class="dv">5</span>, padding<span class="op">=</span><span class="dv">2</span>), nn.ReLU(),</span>
<span id="cb2-9"><a href="#cb2-9"></a>            nn.MaxPool2d(kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb2-10"><a href="#cb2-10"></a>            nn.LazyConv2d(<span class="dv">384</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, padding<span class="op">=</span><span class="dv">1</span>), nn.ReLU(),</span>
<span id="cb2-11"><a href="#cb2-11"></a>            nn.LazyConv2d(<span class="dv">384</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, padding<span class="op">=</span><span class="dv">1</span>), nn.ReLU(),</span>
<span id="cb2-12"><a href="#cb2-12"></a>            nn.LazyConv2d(<span class="dv">256</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, padding<span class="op">=</span><span class="dv">1</span>), nn.ReLU(),</span>
<span id="cb2-13"><a href="#cb2-13"></a>            nn.MaxPool2d(kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>), nn.Flatten(),</span>
<span id="cb2-14"><a href="#cb2-14"></a>            nn.LazyLinear(<span class="dv">4096</span>), nn.ReLU(), nn.Dropout(p<span class="op">=</span><span class="fl">0.5</span>),</span>
<span id="cb2-15"><a href="#cb2-15"></a>            nn.LazyLinear(<span class="dv">4096</span>), nn.ReLU(),nn.Dropout(p<span class="op">=</span><span class="fl">0.5</span>),</span>
<span id="cb2-16"><a href="#cb2-16"></a>            nn.LazyLinear(num_classes))</span>
<span id="cb2-17"><a href="#cb2-17"></a>        <span class="va">self</span>.net.<span class="bu">apply</span>(d2l.init_cnn)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section class="slide level2">

<ul>
<li><strong>construct a single-channel data example</strong> with both height and width of 224 (<strong>to observe the output shape of each layer</strong>). It matches the AlexNet architecture in <code>fig_alexnet</code>.</li>
</ul>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>AlexNet().layer_summary((<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">224</span>, <span class="dv">224</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Conv2d output shape:     torch.Size([1, 96, 54, 54])
ReLU output shape:   torch.Size([1, 96, 54, 54])
MaxPool2d output shape:  torch.Size([1, 96, 26, 26])
Conv2d output shape:     torch.Size([1, 256, 26, 26])
ReLU output shape:   torch.Size([1, 256, 26, 26])
MaxPool2d output shape:  torch.Size([1, 256, 12, 12])
Conv2d output shape:     torch.Size([1, 384, 12, 12])
ReLU output shape:   torch.Size([1, 384, 12, 12])
Conv2d output shape:     torch.Size([1, 384, 12, 12])
ReLU output shape:   torch.Size([1, 384, 12, 12])
Conv2d output shape:     torch.Size([1, 256, 12, 12])
ReLU output shape:   torch.Size([1, 256, 12, 12])
MaxPool2d output shape:  torch.Size([1, 256, 5, 5])
Flatten output shape:    torch.Size([1, 6400])
Linear output shape:     torch.Size([1, 4096])
ReLU output shape:   torch.Size([1, 4096])
Dropout output shape:    torch.Size([1, 4096])
Linear output shape:     torch.Size([1, 4096])
ReLU output shape:   torch.Size([1, 4096])
Dropout output shape:    torch.Size([1, 4096])
Linear output shape:     torch.Size([1, 10])</code></pre>
</div>
</div>
</section>
<section id="training" class="slide level2">
<h2>Training</h2>
<ul>
<li>AlexNet was trained on ImageNet in :citet:<code>Krizhevsky.Sutskever.Hinton.2012</code>, we use Fashion-MNIST here since training an ImageNet model to convergence could take hours or days even on a modern GPU.</li>
<li>One of the problems with applying AlexNet directly on [<strong>Fashion-MNIST</strong>] is that its (<strong>images have lower resolution</strong>) (<span class="math inline">\(28 \times 28\)</span> pixels) (<strong>than ImageNet images.</strong>)</li>
<li>To make things work, (<strong>we upsample them to <span class="math inline">\(224 \times 224\)</span></strong>). This is generally not a smart practice, as it simply increases the computational complexity without adding information. Nonetheless, we do it here to be faithful to the AlexNet architecture.</li>
<li>We perform this resizing with the <code>resize</code> argument in the <code>d2l.FashionMNIST</code> constructor.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>Now, we can [<strong>start training AlexNet.</strong>] Compared to LeNet in :numref:<code>sec_lenet</code>, the main change here is the use of a smaller learning rate and much slower training due to the deeper and wider network, the higher image resolution, and the more costly convolutions.</li>
</ul>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>model <span class="op">=</span> AlexNet(lr<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>data <span class="op">=</span> d2l.FashionMNIST(batch_size<span class="op">=</span><span class="dv">128</span>, resize<span class="op">=</span>(<span class="dv">224</span>, <span class="dv">224</span>))</span>
<span id="cb5-3"><a href="#cb5-3"></a>trainer <span class="op">=</span> d2l.Trainer(max_epochs<span class="op">=</span><span class="dv">10</span>, num_gpus<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co"># trainer.fit(model, data)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="discussion" class="slide level2">
<h2>Discussion</h2>
<ul>
<li>AlexNet’s structure bears a striking resemblance to LeNet, with a number of critical improvements, both for accuracy (dropout) and for ease of training (ReLU).</li>
<li>What is equally striking is the amount of progress that has been made in terms of deep learning tooling.</li>
<li>Reviewing the architecture, we see that AlexNet has an Achilles heel when it comes to efficiency: the last two hidden layers require matrices of size <span class="math inline">\(6400 \times 4096\)</span> and <span class="math inline">\(4096 \times 4096\)</span>, respectively.</li>
<li>This is one of the reasons why AlexNet has been surpassed by much more effective architectures that we will cover in the following sections.</li>
<li>Nonetheless, it is a key step from shallow to deep networks that are used nowadays.</li>
<li>even though the number of parameters by far exceeds the amount of training data in our experiments (the last two layers have more than 40 million parameters, trained on a datasets of 60 thousand images), there is hardly any overfitting: training and validation loss are virtually identical throughout training.</li>
<li>due to the improved regularization, such as Dropout, inherent in modern deep network designs.</li>
</ul>
</section>
<section id="exercises" class="slide level2">
<h2>Exercises</h2>
<ol type="1">
<li>Following up on the discussion above, analyze the computational properties of AlexNet.
<ol type="1">
<li>Compute the memory footprint for convolutions and fully connected layers, respectively. Which one dominates?</li>
<li>Calculate the computational cost for the convolutions and the fully connected layers.</li>
<li>How does the memory (read and write bandwidth, latency, size) affect computation? Is there any difference in its effects for training and inference?</li>
</ol></li>
<li>You are a chip designer and need to trade off computation and memory bandwidth. For example, a faster chip requires more power and possibly a larger chip area. More memory bandwidth requires more pins and control logic, thus also more area. How do you optimize?</li>
<li>Why do engineers no longer report performance benchmarks on AlexNet?</li>
<li>Try increasing the number of epochs when training AlexNet. Compared with LeNet, how do the results differ? Why?</li>
</ol>
</section>
<section class="slide level2">

<ol type="1">
<li>AlexNet may be too complex for the Fashion-MNIST dataset, in particular due to the low resolution of the initial images.
<ol type="1">
<li>Try simplifying the model to make the training faster, while ensuring that the accuracy does not drop significantly.</li>
<li>Design a better model that works directly on <span class="math inline">\(28 \times 28\)</span> images.</li>
</ol></li>
<li>Modify the batch size, and observe the changes in throughput (images/s), accuracy, and GPU memory.</li>
<li>Apply dropout and ReLU to LeNet-5. Does it improve? Can you improve things further by preprocessing to take advantage of the invariances inherent in the images?</li>
<li>Can you make AlexNet overfit? Which feature do you need to remove or change to break training?</li>
</ol>
</section>
<section id="networks-using-blocks-vgg" class="slide level2">
<h2>Networks Using Blocks (VGG)</h2>
<ul>
<li>AlexNet offered empirical evidence that deep CNNs can achieve good results, it did not provide a general template to guide subsequent researchers in designing new networks.</li>
<li>In the following sections, we will introduce several heuristic concepts commonly used to design deep networks.</li>
<li>Progress in this field mirrors that of VLSI (very large scale integration) in chip design where engineers moved from placing transistors to logical elements to logic blocks :cite:<code>Mead.1980</code>.</li>
<li>design of neural network architectures has grown progressively more abstract: individual neurons to whole layers, and now to blocks, repeating patterns of layers.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>A decade later, this has now progressed to researchers using entire trained models to repurpose them for different, albeit related, tasks. Such large pretrained models are typically called <em>foundation models</em> :cite:<code>bommasani2021opportunities</code>.</li>
<li>Back to network design. The idea of using blocks first emerged from the Visual Geometry Group (VGG) at Oxford University, in their eponymously-named <em>VGG</em> network :cite:<code>Simonyan.Zisserman.2014</code>.</li>
<li>It is easy to implement these repeated structures in code with any modern deep learning framework by using loops and subroutines.</li>
</ul>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">from</span> d2l <span class="im">import</span> torch <span class="im">as</span> d2l</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="im">import</span> torch</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="im">from</span> torch <span class="im">import</span> nn</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="vgg-blocks" class="slide level2">
<h2>VGG Blocks</h2>
<ul>
<li>The basic building block of CNNs is a sequence of the following:</li>
<li><ol type="i">
<li>a convolutional layer with padding to maintain the resolution,</li>
</ol></li>
<li><ol start="2" type="i">
<li>a nonlinearity such as a ReLU,</li>
</ol></li>
<li><ol start="3" type="i">
<li>a pooling layer such as max-pooling to reduce the resolution.</li>
</ol></li>
<li>One of the problems with this approach: spatial resolution decreases quite rapidly.</li>
<li>imposes a hard limit of <span class="math inline">\(\log_2 d\)</span> convolutional layers on the network before all dimensions (<span class="math inline">\(d\)</span>) are used up. For instance, in the case of ImageNet, it would be impossible to have more than 8 convolutional layers in this way.</li>
<li>key idea of :citet:<code>Simonyan.Zisserman.2014</code> was to use <em>multiple</em> convolutions in between downsampling via max-pooling in the form of a block.</li>
<li>primarily interested in whether deep or wide networks perform better.</li>
<li>For instance, the successive application of two <span class="math inline">\(3 \times 3\)</span> convolutions touches the same pixels as a single <span class="math inline">\(5 \times 5\)</span> convolution does.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>At the same time, the latter uses approximately as many parameters (<span class="math inline">\(25 \cdot c^2\)</span>) as three <span class="math inline">\(3 \times 3\)</span> convolutions do (<span class="math inline">\(3 \cdot 9 \cdot c^2\)</span>).</li>
<li>In a rather detailed analysis they showed that deep and narrow networks significantly outperform their shallow counterparts. This set deep learning on a quest for ever deeper networks with over 100 layers for typical applications.</li>
<li>Stacking <span class="math inline">\(3 \times 3\)</span> convolutions has become a gold standard in later deep networks (a design decision only to be revisited recently by :citet:<code>liu2022convnet</code>). Consequently, fast implementations for small convolutions have become a staple on GPUs :cite:<code>lavin2016fast</code>.</li>
<li>Back to VGG: a VGG block consists of a <em>sequence</em> of convolutions with <span class="math inline">\(3\times3\)</span> kernels with padding of 1 (keeping height and width) followed by a <span class="math inline">\(2 \times 2\)</span> max-pooling layer with stride of 2 (halving height and width after each block).</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>In the code below, we define a function called <code>vgg_block</code> to implement one VGG block.</li>
<li>The function below takes two arguments, corresponding to the number of convolutional layers <code>num_convs</code> and the number of output channels <code>num_channels</code>.</li>
</ul>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">def</span> vgg_block(num_convs, out_channels):</span>
<span id="cb7-2"><a href="#cb7-2"></a>    layers <span class="op">=</span> []</span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_convs):</span>
<span id="cb7-4"><a href="#cb7-4"></a>        layers.append(nn.LazyConv2d(out_channels, kernel_size<span class="op">=</span><span class="dv">3</span>, padding<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb7-5"><a href="#cb7-5"></a>        layers.append(nn.ReLU())</span>
<span id="cb7-6"><a href="#cb7-6"></a>    layers.append(nn.MaxPool2d(kernel_size<span class="op">=</span><span class="dv">2</span>,stride<span class="op">=</span><span class="dv">2</span>))</span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="cf">return</span> nn.Sequential(<span class="op">*</span>layers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="vgg-network" class="slide level2">
<h2>VGG Network</h2>
<ul>
<li>VGG Network can be partitioned into two parts:
<ul>
<li>first consisting mostly of convolutional and pooling layers</li>
<li>second consisting of fully connected layers that are identical to those in AlexNet.</li>
</ul></li>
<li>key difference : convolutional layers are grouped in nonlinear transformations that leave the dimensonality unchanged, followed by a resolution-reduction step, as depicted in :numref:<code>fig_vgg</code>.</li>
</ul>
<p><img data-src="../img/vgg.svg" style="width:30.0%" data-centered="true" alt="From AlexNet to VGG. The key difference is that VGG consists of blocks of layers, whereas AlexNet’s layers are all designed individually."> <code>fig_vgg</code></p>
</section>
<section class="slide level2">

<ul>
<li>convolutional part of the network connects several VGG blocks from :numref:<code>fig_vgg</code> (also defined in the <code>vgg_block</code> function) in succession. This grouping of convolutions is a pattern that has remained almost unchanged over the past decade, although the specific choice of operations has undergone considerable modifications.</li>
<li>The variable <code>arch</code> consists of a list of tuples (one per block), where each contains two values: the number of convolutional layers and the number of output channels, which are precisely the arguments required to call the <code>vgg_block</code> function.</li>
<li>As such, VGG defines a <em>family</em> of networks rather than just a specific manifestation. To build a specific network we simply iterate over <code>arch</code> to compose the blocks.</li>
</ul>
</section>
<section class="slide level2">

<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">class</span> VGG(d2l.Classifier):</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, arch, lr<span class="op">=</span><span class="fl">0.1</span>, num_classes<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb8-3"><a href="#cb8-3"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb8-4"><a href="#cb8-4"></a>        <span class="va">self</span>.save_hyperparameters()</span>
<span id="cb8-5"><a href="#cb8-5"></a>        conv_blks <span class="op">=</span> []</span>
<span id="cb8-6"><a href="#cb8-6"></a>        <span class="cf">for</span> (num_convs, out_channels) <span class="kw">in</span> arch:</span>
<span id="cb8-7"><a href="#cb8-7"></a>            conv_blks.append(vgg_block(num_convs, out_channels))</span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(</span>
<span id="cb8-9"><a href="#cb8-9"></a>            <span class="op">*</span>conv_blks, nn.Flatten(),</span>
<span id="cb8-10"><a href="#cb8-10"></a>            nn.LazyLinear(<span class="dv">4096</span>), nn.ReLU(), nn.Dropout(<span class="fl">0.5</span>),</span>
<span id="cb8-11"><a href="#cb8-11"></a>            nn.LazyLinear(<span class="dv">4096</span>), nn.ReLU(), nn.Dropout(<span class="fl">0.5</span>),</span>
<span id="cb8-12"><a href="#cb8-12"></a>            nn.LazyLinear(num_classes))</span>
<span id="cb8-13"><a href="#cb8-13"></a>        <span class="va">self</span>.net.<span class="bu">apply</span>(d2l.init_cnn)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>original VGG network had 5 convolutional blocks, among which the first two have one convolutional layer each and the latter three contain two convolutional layers each.</li>
<li>The first block has 64 output channels and each subsequent block doubles the number of output channels, until that number reaches 512.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>Since this network uses 8 convolutional layers and 3 fully connected layers, it is often called VGG-11.</li>
</ul>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>VGG(arch<span class="op">=</span>((<span class="dv">1</span>, <span class="dv">64</span>), (<span class="dv">1</span>, <span class="dv">128</span>), (<span class="dv">2</span>, <span class="dv">256</span>), (<span class="dv">2</span>, <span class="dv">512</span>), (<span class="dv">2</span>, <span class="dv">512</span>))).layer_summary(</span>
<span id="cb9-2"><a href="#cb9-2"></a>    (<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">224</span>, <span class="dv">224</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Sequential output shape:     torch.Size([1, 64, 112, 112])
Sequential output shape:     torch.Size([1, 128, 56, 56])
Sequential output shape:     torch.Size([1, 256, 28, 28])
Sequential output shape:     torch.Size([1, 512, 14, 14])
Sequential output shape:     torch.Size([1, 512, 7, 7])
Flatten output shape:    torch.Size([1, 25088])
Linear output shape:     torch.Size([1, 4096])
ReLU output shape:   torch.Size([1, 4096])
Dropout output shape:    torch.Size([1, 4096])
Linear output shape:     torch.Size([1, 4096])
ReLU output shape:   torch.Size([1, 4096])
Dropout output shape:    torch.Size([1, 4096])
Linear output shape:     torch.Size([1, 10])</code></pre>
</div>
</div>
<ul>
<li>halve height and width at each block, finally reaching a height and width of 7 before flattening the representations for processing by the fully connected part of the network.</li>
</ul>
</section>
<section id="training-1" class="slide level2">
<h2>Training</h2>
<ul>
<li><strong>VGG-11 is computationally more demanding than AlexNet we construct a network with a smaller number of channels.</strong></li>
<li>more than sufficient for training on Fashion-MNIST.</li>
<li><strong>model training</strong> process is similar to that of AlexNet in <code>sec_alexnet</code>.</li>
<li>observe the close match between validation and training loss, suggesting only a small amount of overfitting.</li>
</ul>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>model <span class="op">=</span> VGG(arch<span class="op">=</span>((<span class="dv">1</span>, <span class="dv">16</span>), (<span class="dv">1</span>, <span class="dv">32</span>), (<span class="dv">2</span>, <span class="dv">64</span>), (<span class="dv">2</span>, <span class="dv">128</span>), (<span class="dv">2</span>, <span class="dv">128</span>)), lr<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb11-2"><a href="#cb11-2"></a>trainer <span class="op">=</span> d2l.Trainer(max_epochs<span class="op">=</span><span class="dv">10</span>, num_gpus<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb11-3"><a href="#cb11-3"></a>data <span class="op">=</span> d2l.FashionMNIST(batch_size<span class="op">=</span><span class="dv">128</span>, resize<span class="op">=</span>(<span class="dv">224</span>, <span class="dv">224</span>))</span>
<span id="cb11-4"><a href="#cb11-4"></a>model.apply_init([<span class="bu">next</span>(<span class="bu">iter</span>(data.get_dataloader(<span class="va">True</span>)))[<span class="dv">0</span>]], d2l.init_cnn)</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co"># trainer.fit(model, data)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="summary" class="slide level2">
<h2>Summary</h2>
<ul>
<li>might argue that VGG is the first truly modern convolutional neural network.</li>
<li>VGG introduced key properties such as blocks of multiple convolutions and a preference for deep and narrow networks.</li>
<li>first network that is actually an entire family of similarly parametrized models, giving the practitioner ample trade-off between complexity and speed.</li>
</ul>
</section>
<section id="exercises-1" class="slide level2">
<h2>Exercises</h2>
<ol type="1">
<li>Compared with AlexNet, VGG is much slower in terms of computation, and it also needs more GPU memory.
<ol type="1">
<li>Compare the number of parameters needed for AlexNet and VGG.</li>
<li>Compare the number of floating point operations used in the convolutional layers and in the fully connected layers.</li>
<li>How could you reduce the computational cost created by the fully connected layers?</li>
</ol></li>
<li>When displaying the dimensions associated with the various layers of the network, we only see the information associated with 8 blocks (plus some auxiliary transforms), even though the network has 11 layers. Where did the remaining 3 layers go?</li>
<li>Use Table 1 in the VGG paper :cite:<code>Simonyan.Zisserman.2014</code> to construct other common models, such as VGG-16 or VGG-19.</li>
<li>Upsampling the resolution in Fashion-MNIST by a factor of <span class="math inline">\(8\)</span> from <span class="math inline">\(28 \times 28\)</span> to <span class="math inline">\(224 \times 224\)</span> dimensions is very wasteful. Try modifying the network architecture and resolution conversion, e.g., to 56 or to 84 dimensions for its input instead. Can you do so without reducing the accuracy of the network? Consider the VGG paper :cite:<code>Simonyan.Zisserman.2014</code> for ideas on adding more nonlinearities prior to downsampling.</li>
</ol>
</section>
<section id="network-in-network-nin" class="slide level2">
<h2>Network in Network (NiN)</h2>
<ul>
<li>LeNet, AlexNet, and VGG all share a common design pattern: extract features exploiting <em>spatial</em> structure via a sequence of convolutions and pooling layers and post-process the representations via fully connected layers.</li>
<li>design poses two major challenges.</li>
<li>the fully connected layers at the end of the architecture consume tremendous numbers of parameters.</li>
<li>For instance, even a simple model such as VGG-11 requires a monstrous <span class="math inline">\(25088 \times 4096\)</span> matrix, occupying almost 400MB of RAM in single precision (FP32).</li>
<li>significant impediment to computation, in particular on mobile and embedded devices.</li>
<li>After all, even high-end mobile phones sport no more than 8GB of RAM. At the time VGG was invented, this was an order of magnitude less (the iPhone 4S had 512MB).</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>As such, it would have been difficult to justify spending the majority of memory on an image classifier.</li>
<li>equally impossible to add fully connected layers earlier in the network to increase the degree of nonlinearity: doing so would destroy the spatial structure and require potentially even more memory.</li>
<li><em>network in network</em> (<em>NiN</em>) blocks :cite:<code>Lin.Chen.Yan.2013</code> offer an alternative, capable of solving both problems in one simple strategy.</li>
<li>proposed based on a very simple insight:</li>
<li><ol type="i">
<li>use <span class="math inline">\(1 \times 1\)</span> convolutions to add local nonlinearities across the channel activations<br>
</li>
</ol></li>
<li><ol start="2" type="i">
<li>use global average pooling to integrate across all locations in the last representation layer.</li>
</ol></li>
<li>Note that global average pooling would not be effective, were it not for the added nonlinearities. Let’s dive into this in detail.</li>
</ul>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="im">from</span> d2l <span class="im">import</span> torch <span class="im">as</span> d2l</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="im">import</span> torch</span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="im">from</span> torch <span class="im">import</span> nn</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="nin-blocks" class="slide level2">
<h2>NiN Blocks</h2>
<ul>
<li>Recall :numref:<code>subsec_1x1</code>. In it we discussed that the inputs and outputs of convolutional layers consist of four-dimensional tensors with axes corresponding to the example, channel, height, and width.</li>
<li>Also recall that the inputs and outputs of fully connected layers are typically two-dimensional tensors corresponding to the example and feature.</li>
<li>The idea behind NiN is to apply a fully connected layer at each pixel location (for each height and width).</li>
<li>The resulting <span class="math inline">\(1 \times 1\)</span> convolution can be thought as a fully connected layer acting independently on each pixel location.</li>
<li>:numref:<code>fig_nin</code> illustrates the main structural differences between VGG and NiN, and their blocks.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>Note both the difference in the NiN blocks (the initial convolution is followed by <span class="math inline">\(1 \times 1\)</span> convolutions, whereas VGG retains <span class="math inline">\(3 \times 3\)</span> convolutions) and in the end where we no longer require a giant fully connected layer.</li>
</ul>
<p><img data-src="../img/nin.svg" alt="Comparing the architectures of VGG and NiN, and of their blocks."> :width:<code>600px</code> :label:<code>fig_nin</code></p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">def</span> nin_block(out_channels, kernel_size, strides, padding):</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="cf">return</span> nn.Sequential(</span>
<span id="cb13-3"><a href="#cb13-3"></a>        nn.LazyConv2d(out_channels, kernel_size, strides, padding), nn.ReLU(),</span>
<span id="cb13-4"><a href="#cb13-4"></a>        nn.LazyConv2d(out_channels, kernel_size<span class="op">=</span><span class="dv">1</span>), nn.ReLU(),</span>
<span id="cb13-5"><a href="#cb13-5"></a>        nn.LazyConv2d(out_channels, kernel_size<span class="op">=</span><span class="dv">1</span>), nn.ReLU())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="nin-model" class="slide level2">
<h2>NiN Model</h2>
<ul>
<li>NiN uses the same initial convolution sizes as AlexNet (it was proposed shortly thereafter).</li>
<li>The kernel sizes are <span class="math inline">\(11\times 11\)</span>, <span class="math inline">\(5\times 5\)</span>, and <span class="math inline">\(3\times 3\)</span>, respectively, and the numbers of output channels match those of AlexNet. Each NiN block is followed by a max-pooling layer with a stride of 2 and a window shape of <span class="math inline">\(3\times 3\)</span>.</li>
<li>The second significant difference between NiN and both AlexNet and VGG is that NiN avoids fully connected layers altogether.</li>
<li>Instead, NiN uses a NiN block with a number of output channels equal to the number of label classes, followed by a <em>global</em> average pooling layer, yielding a vector of logits.</li>
<li>This design significantly reduces the number of required model parameters, albeit at the expense of a potential increase in training time.</li>
</ul>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">class</span> NiN(d2l.Classifier):</span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, lr<span class="op">=</span><span class="fl">0.1</span>, num_classes<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb14-3"><a href="#cb14-3"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb14-4"><a href="#cb14-4"></a>        <span class="va">self</span>.save_hyperparameters()</span>
<span id="cb14-5"><a href="#cb14-5"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(</span>
<span id="cb14-6"><a href="#cb14-6"></a>            nin_block(<span class="dv">96</span>, kernel_size<span class="op">=</span><span class="dv">11</span>, strides<span class="op">=</span><span class="dv">4</span>, padding<span class="op">=</span><span class="dv">0</span>),</span>
<span id="cb14-7"><a href="#cb14-7"></a>            nn.MaxPool2d(<span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb14-8"><a href="#cb14-8"></a>            nin_block(<span class="dv">256</span>, kernel_size<span class="op">=</span><span class="dv">5</span>, strides<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb14-9"><a href="#cb14-9"></a>            nn.MaxPool2d(<span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb14-10"><a href="#cb14-10"></a>            nin_block(<span class="dv">384</span>, kernel_size<span class="op">=</span><span class="dv">3</span>, strides<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb14-11"><a href="#cb14-11"></a>            nn.MaxPool2d(<span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb14-12"><a href="#cb14-12"></a>            nn.Dropout(<span class="fl">0.5</span>),</span>
<span id="cb14-13"><a href="#cb14-13"></a>            nin_block(num_classes, kernel_size<span class="op">=</span><span class="dv">3</span>, strides<span class="op">=</span><span class="dv">1</span>, padding<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb14-14"><a href="#cb14-14"></a>            nn.AdaptiveAvgPool2d((<span class="dv">1</span>, <span class="dv">1</span>)),</span>
<span id="cb14-15"><a href="#cb14-15"></a>            nn.Flatten())</span>
<span id="cb14-16"><a href="#cb14-16"></a>        <span class="va">self</span>.net.<span class="bu">apply</span>(d2l.init_cnn)        </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section class="slide level2">

<ul>
<li>create a data example to see <strong>the output shape of each block</strong></li>
</ul>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a>NiN().layer_summary((<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">224</span>, <span class="dv">224</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Sequential output shape:     torch.Size([1, 96, 54, 54])
MaxPool2d output shape:  torch.Size([1, 96, 26, 26])
Sequential output shape:     torch.Size([1, 256, 26, 26])
MaxPool2d output shape:  torch.Size([1, 256, 12, 12])
Sequential output shape:     torch.Size([1, 384, 12, 12])
MaxPool2d output shape:  torch.Size([1, 384, 5, 5])
Dropout output shape:    torch.Size([1, 384, 5, 5])
Sequential output shape:     torch.Size([1, 10, 5, 5])
AdaptiveAvgPool2d output shape:  torch.Size([1, 10, 1, 1])
Flatten output shape:    torch.Size([1, 10])</code></pre>
</div>
</div>
</section>
<section id="training-2" class="slide level2">
<h2>Training</h2>
<ul>
<li>use Fashion-MNIST to train the model</li>
</ul>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a>model <span class="op">=</span> NiN(lr<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb17-2"><a href="#cb17-2"></a>trainer <span class="op">=</span> d2l.Trainer(max_epochs<span class="op">=</span><span class="dv">10</span>, num_gpus<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-3"><a href="#cb17-3"></a>data <span class="op">=</span> d2l.FashionMNIST(batch_size<span class="op">=</span><span class="dv">128</span>, resize<span class="op">=</span>(<span class="dv">224</span>, <span class="dv">224</span>))</span>
<span id="cb17-4"><a href="#cb17-4"></a>model.apply_init([<span class="bu">next</span>(<span class="bu">iter</span>(data.get_dataloader(<span class="va">True</span>)))[<span class="dv">0</span>]], d2l.init_cnn)</span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="co"># trainer.fit(model, data)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="summary-1" class="slide level2">
<h2>Summary</h2>
<ul>
<li>NiN has dramatically fewer parameters than AlexNet and VGG.</li>
<li>stems primarily from the fact that it needs no giant fully connected layers.</li>
<li>Instead, uses global average pooling to aggregate across all image locations after the last stage of the network body.</li>
<li>obviates the need for expensive (learned) reduction operations and replaces them by a simple average.</li>
<li>averaging operation does not harm accuracy.</li>
<li>averaging across a low-resolution representation (with many channels) also adds to the amount of translation invariance that the network can handle.</li>
<li>choosing fewer convolutions with wide kernels and replacing them by <span class="math inline">\(1 \times 1\)</span> convolutions aids the quest for fewer parameters further.</li>
<li>affords for a significant amount of nonlinearity across channels within any given location.</li>
<li>Both <span class="math inline">\(1 \times 1\)</span> convolutions and global average pooling significantly influenced subsequent CNN designs.</li>
</ul>
</section>
<section id="exercises-2" class="slide level2">
<h2>Exercises</h2>
<ol type="1">
<li>Why are there two <span class="math inline">\(1\times 1\)</span> convolutional layers per NiN block? Increase their number to three. Reduce their number to one. What changes?</li>
<li>What changes if you replace the <span class="math inline">\(1 \times 1\)</span> convolutions by <span class="math inline">\(3 \times 3\)</span> convolutions?</li>
<li>What happens if you replace the global average pooling by a fully connected layer (speed, accuracy, number of parameters)?</li>
<li>Calculate the resource usage for NiN.
<ol type="1">
<li>What is the number of parameters?</li>
<li>What is the amount of computation?</li>
<li>What is the amount of memory needed during training?</li>
<li>What is the amount of memory needed during prediction?</li>
</ol></li>
<li>What are possible problems with reducing the <span class="math inline">\(384 \times 5 \times 5\)</span> representation to a <span class="math inline">\(10 \times 5 \times 5\)</span> representation in one step?</li>
<li>Use the structural design decisions in VGG that led to VGG-11, VGG-16, and VGG-19 to design a family of NiN-like networks.</li>
</ol>
</section>
<section id="batch-normalization" class="slide level2">
<h2>Batch Normalization</h2>
<ul>
<li>Training deep neural networks is difficult.</li>
<li>Getting them to converge in a reasonable amount of time can be tricky.</li>
<li>In this section, we describe <em>batch normalization</em>, a popular and effective technique that consistently accelerates the convergence of deep networks :cite:<code>Ioffe.Szegedy.2015</code>.</li>
<li>Together with residual blocks—covered later in :numref:<code>sec_resnet</code>—batch normalization has made it possible for practitioners to routinely train networks with over 100 layers.</li>
<li>A secondary (serendipitous) benefit of batch normalization lies in its inherent regularization.</li>
</ul>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="im">from</span> d2l <span class="im">import</span> torch <span class="im">as</span> d2l</span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="im">import</span> torch</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="im">from</span> torch <span class="im">import</span> nn</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="training-deep-networks" class="slide level2">
<h2>Training Deep Networks</h2>
<ul>
<li>When working with data, we often preprocess before training.</li>
<li>Choices regarding data preprocessing often make an enormous difference in the final results.</li>
<li>Recall our application of MLPs to predicting house prices (:numref:<code>sec_kaggle_house</code>).</li>
<li>first step when working with real data: standardize our input features to have zero mean <span class="math inline">\(\boldsymbol{\mu} = 0\)</span> and unit variance <span class="math inline">\(\boldsymbol{\Sigma} = \boldsymbol{1}\)</span> cross multiple observations :cite:<code>friedman1987exploratory</code>.</li>
<li>one frequently rescales it such that the diagonal is unity, i.e., <span class="math inline">\(\Sigma_ ii} = 1\)</span>.</li>
<li>another strategy is to rescale vectors to unit length, possibly zero mean <em>per observation</em>.</li>
<li>can work well, e.g., for spatial sensor data. These preprocessing techniques and many more are beneficial to keep the estimation problem well controlled.</li>
<li>standardizing vectors also has the nice side-effect of constraining the function complexity of functions that act upon it.</li>
<li>Intuitively, this standardization plays nicely with our optimizers since it puts the parameters <em>a priori</em> at a similar scale.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>natural to ask whether a corresponding normalization step <em>inside</em> a deep network might not be beneficial</li>
<li>useful way of understanding it and its cousin, layer normalization :cite:<code>Ba.Kiros.Hinton.2016</code> within a unified framework.</li>
<li>Second, for a typical MLP or CNN, as we train, the variables in intermediate layers (e.g., affine transformation outputs in MLP) may take values with widely varying magnitudes:
<ul>
<li>both along the layers from input to output, across units in the same layer, and over time due to our updates to the model parameters.</li>
<li>inventors of batch normalization postulated informally that this drift in the distribution of such variables could hamper the convergence of the network.</li>
</ul></li>
<li>Intuitively, we might conjecture that if one layer has variable activations that are 100 times that of another layer, this might necessitate compensatory adjustments in the learning rates.</li>
<li>Adaptive solvers such as AdaGrad :cite:<code>Duchi.Hazan.Singer.2011</code>, Adam :cite:<code>Kingma.Ba.2014</code>, Yogi :cite:<code>Zaheer.Reddi.Sachan.ea.2018</code>, or Distributed Shampoo :cite:<code>anil2020scalable</code> aim to address this from the viewpoint of optimization, e.g., by adding aspects of second-order methods.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>alternative is to prevent the problem from occurring, simply by adaptive normalization.</li>
<li>deeper networks are complex –&gt; overfitting.</li>
<li>regularization becomes more critical. A common technique for regularization is noise injection.</li>
<li>has been known for a long time, e.g., with regard to noise injection for the inputs :cite:<code>Bishop.1995</code>. It also forms the basis of dropout in :numref:<code>sec_dropout</code>.</li>
<li>batch normalization conveys all three benefits: preprocessing, numerical stability, and regularization.</li>
<li>Batch normalization is applied to individual layers, or optionally, to all of them:</li>
<li>In each training iteration, we first normalize the inputs (of batch normalization) by subtracting their mean and dividing by their standard deviation, where both are estimated based on the statistics of the current minibatch.</li>
<li>Next, we apply a scale coefficient and an offset to recover the lost degrees of freedom. It is precisely due to this <em>normalization</em> based on <em>batch</em> statistics that <em>batch normalization</em> derives its name.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>Note that if we tried to apply batch normalization with minibatches of size 1, we would not be able to learn anything.</li>
<li>That is because after subtracting the means, each hidden unit would take value 0.</li>
<li>As you might guess, since we are devoting a whole section to batch normalization, with large enough minibatches, the approach proves effective and stable.</li>
<li>One takeaway here is that when applying batch normalization, the choice of batch size is even more significant than without batch normalization, or at least, suitable calibration is needed as we might adjust it.</li>
<li>Denote by <span class="math inline">\(\mathcal{B}\)</span> a minibatch and let <span class="math inline">\(\mathbf{x} \in \mathcal{B}\)</span> be an input to batch normalization (<span class="math inline">\(\mathrm{BN}\)</span>). In this case the batch normalization is defined as follows:</li>
<li><span class="math display">\[\mathrm{BN}(\mathbf{x}) = \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta}.\]</span> :eqlabel:<code>eq_batchnorm</code></li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>In :eqref:<code>eq_batchnorm</code>, <span class="math inline">\(\hat{\boldsymbol{\mu}}_\mathcal{B}\)</span> is the sample mean and <span class="math inline">\(\hat{\boldsymbol{\sigma}}_\mathcal{B}\)</span> is the sample standard deviation of the minibatch <span class="math inline">\(\mathcal{B}\)</span>.</li>
<li>After applying standardization, the resulting minibatch has zero mean and unit variance. The choice of unit variance (vs.&nbsp;some other magic number) is an arbitrary choice. We recover this degree of freedom by including an elementwise <em>scale parameter</em> <span class="math inline">\(\boldsymbol{\gamma}\)</span> and <em>shift parameter</em> <span class="math inline">\(\boldsymbol{\beta}\)</span> that have the same shape as <span class="math inline">\(\mathbf{x}\)</span>. Both are parameters that need to be learned as part of model training.</li>
<li>The variable magnitudes for intermediate layers cannot diverge during training since batch normalization actively centers and rescales them back to a given mean and size (via <span class="math inline">\(\hat \boldsymbol{\mu}}_\mathcal{B}\)</span> and <span class="math inline">\({\hat{\boldsymbol{\sigma}}_\mathcal{B}}\)</span>).</li>
<li>Practical experience confirms that, as alluded to when discussing feature rescaling, batch normalization seems to allow for more aggressive learning rates.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>We calculate <span class="math inline">\(\hat{\boldsymbol{\mu}}_\mathcal{B}\)</span> and <span class="math inline">\({\hat{\boldsymbol{\sigma}}_\mathcal{B}}\)</span> in :eqref:<code>eq_batchnorm</code> as follows:</li>
</ul>
<p><span class="math display">\[\hat{\boldsymbol{\mu}}_\mathcal{B} = \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} \mathbf{x}
\text{ and }
\hat{\boldsymbol{\sigma}}_\mathcal{B}^2 = \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} (\mathbf{x} - \hat{\boldsymbol{\mu}}_{\mathcal{B}})^2 + \epsilon.\]</span></p>
<ul>
<li>Note that we add a small constant <span class="math inline">\(\epsilon &gt; 0\)</span> to the variance estimate to ensure that we never attempt division by zero, even in cases where the empirical variance estimate might be very small or even vanish.</li>
<li>The estimates <span class="math inline">\(\hat{\boldsymbol{\mu}}_\mathcal{B}\)</span> and <span class="math inline">\({\hat{\boldsymbol{\sigma}}_\mathcal{B}}\)</span> counteract the scaling issue by using noisy estimates of mean and variance.</li>
<li>You might think that this noisiness should be a problem. Quite to the contrary, this is actually beneficial.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>This turns out to be a recurring theme in deep learning. For reasons that are not yet well-characterized theoretically, various sources of noise in optimization often lead to faster training and less overfitting:</li>
<li>this variation appears to act as a form of regularization. :citet:<code>Teye.Azizpour.Smith.2018</code> and :citet:<code>Luo.Wang.Shao.ea.2018</code> related the properties of batch normalization to Bayesian priors and penalties, respectively.</li>
<li>In particular, this sheds some light on the puzzle of why batch normalization works best for moderate minibatches sizes in the <span class="math inline">\(50 \sim 100\)</span> range.</li>
<li>This particular size of minibatch seems to inject just the “right amount” of noise per layer, both in terms of scale via <span class="math inline">\(\hat{\boldsymbol{\sigma}}\)</span>, and in terms of offset via <span class="math inline">\(\hat{\boldsymbol{\mu}}\)</span>:</li>
<li>a larger minibatch regularizes less due to the more stable estimates, whereas tiny minibatches destroy useful signal due to high variance.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>Exploring this direction further, considering alternative types of preprocessing and filtering may yet lead to other effective types of regularization.</li>
<li>Fixing a trained model, you might think that we would prefer using the entire dataset to estimate the mean and variance.</li>
<li>Once training is complete, why would we want the same image to be classified differently, depending on the batch in which it happens to reside?</li>
<li>During training, such exact calculation is infeasible because the intermediate variables for all data examples change every time we update our model.</li>
<li>However, once the model is trained, we can calculate the means and variances of each layer’s variables based on the entire dataset.</li>
<li>Indeed this is standard practice for models employing batch normalization and thus batch normalization layers function differently in <em>training mode</em> (normalizing by minibatch statistics) and in <em>prediction mode</em> (normalizing by dataset statistics).</li>
<li>In this form they closely resemble the behavior of dropout regularization of :numref:<code>sec_dropout</code>, where noise is only injected during training.</li>
</ul>
</section>
<section id="batch-normalization-layers" class="slide level2">
<h2>Batch Normalization Layers</h2>
<ul>
<li>Batch normalization implementations for fully connected layers and convolutional layers are slightly different.</li>
<li>One key difference between batch normalization and other layers is that because batch normalization operates on a full minibatch at a time, we cannot just ignore the batch dimension as we did before when introducing other layers.</li>
</ul>
</section>
<section id="fully-connected-layers" class="slide level2">
<h2>Fully Connected Layers</h2>
<ul>
<li>When applying batch normalization to fully connected layers, the original paper inserted batch normalization after the affine transformation and <em>before</em> the nonlinear activation function. Later applications experimented with inserting batch normalization right <em>after</em> activation functions :cite:<code>Ioffe.Szegedy.2015</code>.</li>
<li>Denoting the input to the fully connected layer by <span class="math inline">\(\mathbf{x}\)</span>, the affine transformation by <span class="math inline">\(\mathbf{W}\mathbf{x} + \mathbf{b}\)</span> (with the weight parameter <span class="math inline">\(\mathbf{W}\)</span> and the bias parameter <span class="math inline">\(\mathbf{b}\)</span>), and the activation function by <span class="math inline">\(\phi\)</span>, we can express the computation of a batch-normalization-enabled, fully connected layer output <span class="math inline">\(\mathbf{h}\)</span> as follows:</li>
</ul>
<p><span class="math display">\[\mathbf{h} = \phi(\mathrm{BN}(\mathbf{W}\mathbf{x} + \mathbf{b}) ).\]</span></p>
<ul>
<li>Recall that mean and variance are computed on the <em>same</em> minibatch on which the ransformation is applied.</li>
</ul>
</section>
<section id="convolutional-layers" class="slide level2">
<h2>Convolutional Layers</h2>
<ul>
<li>Similarly, with convolutional layers, we can apply batch normalization after the convolution and before the nonlinear activation function. The key difference from batch normalization in fully connected layers is that we apply the operation on a per-channel basis <em>across all locations</em>.</li>
<li>This is compatible with our assumption of translation invariance that led to convolutions: we assumed that the specific location of a pattern within an image was not critical for the purpose of understanding.</li>
<li>Assume that our minibatches contain <span class="math inline">\(m\)</span> examples and that for each channel, the output of the convolution has height <span class="math inline">\(p\)</span> and width <span class="math inline">\(q\)</span>.</li>
<li>For convolutional layers, we carry out each batch normalization over the <span class="math inline">\(m \cdot p \cdot q\)</span> elements per output channel simultaneously.</li>
<li>Thus, we collect the values over all spatial locations when computing the mean and variance and consequently apply the same mean and variance within a given channel to normalize the value at each spatial location.</li>
<li>Each channel has its own scale and shift parameters, both of which are scalars.</li>
</ul>
</section>
<section id="layer-normalization" class="slide level2">
<h2>Layer Normalization</h2>
<ul>
<li>Note that in the context of convolutions the batch normalization is well-defined even for minibatches of size 1: after all, we have all the locations across an image to average</li>
<li>consequently, mean and variance are well defined, even if it is just within a single observation.</li>
<li>This consideration led :citet:<code>Ba.Kiros.Hinton.2016</code> to introduce the notion of <em>layer normalization</em>.</li>
<li>It works just like a batch norm, only that it is applied to one observation at a time. Consequently both the offset and the scaling factor are scalars. Given an <span class="math inline">\(n\)</span>-dimensional vector <span class="math inline">\(\mathbf{x}\)</span> layer norms are given by</li>
</ul>
<p><span class="math display">\[\mathbf{x} \rightarrow \mathrm{LN}(\mathbf{x}) =  \frac{\mathbf{x} - \hat{\mu}}{\hat\sigma},\]</span></p>
<p>where scaling and offset are applied coefficient-wise and given by</p>
<p><span class="math display">\[\hat{\mu} \stackrel{\mathrm{def}}{=} \frac{1}{n} \sum_{i=1}^n x_i \text{ and }
\hat{\sigma}^2 \stackrel{\mathrm{def}}{=} \frac{1}{n} \sum_{i=1}^n (x_i - \hat{\mu})^2 + \epsilon.\]</span></p>
</section>
<section class="slide level2">

<ul>
<li>As before we add a small offset <span class="math inline">\(\epsilon &gt; 0\)</span> to prevent division by zero.</li>
<li>One of the major benefits of using layer normalization is that it prevents divergence.</li>
<li>After all, ignoring <span class="math inline">\(\epsilon\)</span>, the output of the layer normalization is scale independent.</li>
<li>That is, we have <span class="math inline">\(\mathrm{LN}(\mathbf{x}) \approx \mathrm{LN}(\alpha \mathbf{x})\)</span> for any choice of <span class="math inline">\(\alpha \neq 0\)</span>.</li>
<li>This becomes an equality for <span class="math inline">\(|\alpha| \to \infty\)</span> (the approximate equality is due to the offset <span class="math inline">\(\epsilon\)</span> for the variance).</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>Another advantage of the layer normalization is that it does not depend on the minibatch size.</li>
<li>It is also independent of whether we are in training or test regime.</li>
<li>In other words, it is simply a deterministic transformation that standardizes the activations to a given scale.</li>
<li>This can be very beneficial in preventing divergence in optimization. We skip further details and recommend the interested reader to consult the original paper.</li>
</ul>
</section>
<section id="batch-normalization-during-prediction" class="slide level2">
<h2>Batch Normalization During Prediction</h2>
<ul>
<li>mentioned earlier, batch normalization typically behaves differently in training mode and prediction mode.</li>
<li>First, the noise in the sample mean and the sample variance arising from estimating each on minibatches are no longer desirable once we have trained the model.</li>
<li>Second, we might not have the luxury of computing per-batch normalization statistics.</li>
<li>For example, we might need to apply our model to make one prediction at a time.</li>
<li>Typically, after training, we use the entire dataset to compute stable estimates of the variable statistics and then fix them at prediction time.</li>
<li>Consequently, batch normalization behaves differently during training and at test time. Recall that dropout also exhibits this characteristic.</li>
</ul>
</section>
<section id="implementation-from-scratch" class="slide level2">
<h2>Implementation from Scratch</h2>
<ul>
<li>To see how batch normalization works in practice, we implement one from scratch below.</li>
</ul>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">def</span> batch_norm(X, gamma, beta, moving_mean, moving_var, eps, momentum):</span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="co">## Use is_grad_enabled to determine whether we are in training mode</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="cf">if</span> <span class="kw">not</span> torch.is_grad_enabled():</span>
<span id="cb19-4"><a href="#cb19-4"></a>        <span class="co">## In prediction mode, use mean and variance obtained by moving average</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>        X_hat <span class="op">=</span> (X <span class="op">-</span> moving_mean) <span class="op">/</span> torch.sqrt(moving_var <span class="op">+</span> eps)</span>
<span id="cb19-6"><a href="#cb19-6"></a>    <span class="cf">else</span>:</span>
<span id="cb19-7"><a href="#cb19-7"></a>        <span class="cf">assert</span> <span class="bu">len</span>(X.shape) <span class="kw">in</span> (<span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb19-8"><a href="#cb19-8"></a>        <span class="cf">if</span> <span class="bu">len</span>(X.shape) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb19-9"><a href="#cb19-9"></a>            <span class="co">## When using a fully connected layer, calculate the mean and</span></span>
<span id="cb19-10"><a href="#cb19-10"></a>            <span class="co">## variance on the feature dimension</span></span>
<span id="cb19-11"><a href="#cb19-11"></a>            mean <span class="op">=</span> X.mean(dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb19-12"><a href="#cb19-12"></a>            var <span class="op">=</span> ((X <span class="op">-</span> mean) <span class="op">**</span> <span class="dv">2</span>).mean(dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb19-13"><a href="#cb19-13"></a>        <span class="cf">else</span>:</span>
<span id="cb19-14"><a href="#cb19-14"></a>            <span class="co">## When using a two-dimensional convolutional layer, calculate the</span></span>
<span id="cb19-15"><a href="#cb19-15"></a>            <span class="co">## mean and variance on the channel dimension (axis=1). Here we</span></span>
<span id="cb19-16"><a href="#cb19-16"></a>            <span class="co">## need to maintain the shape of X, so that the broadcasting</span></span>
<span id="cb19-17"><a href="#cb19-17"></a>            <span class="co">## operation can be carried out later</span></span>
<span id="cb19-18"><a href="#cb19-18"></a>            mean <span class="op">=</span> X.mean(dim<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>), keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-19"><a href="#cb19-19"></a>            var <span class="op">=</span> ((X <span class="op">-</span> mean) <span class="op">**</span> <span class="dv">2</span>).mean(dim<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>), keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-20"><a href="#cb19-20"></a>        <span class="co">## In training mode, the current mean and variance are used </span></span>
<span id="cb19-21"><a href="#cb19-21"></a>        X_hat <span class="op">=</span> (X <span class="op">-</span> mean) <span class="op">/</span> torch.sqrt(var <span class="op">+</span> eps)</span>
<span id="cb19-22"><a href="#cb19-22"></a>        <span class="co">## Update the mean and variance using moving average</span></span>
<span id="cb19-23"><a href="#cb19-23"></a>        moving_mean <span class="op">=</span> (<span class="fl">1.0</span> <span class="op">-</span> momentum) <span class="op">*</span> moving_mean <span class="op">+</span> momentum <span class="op">*</span> mean</span>
<span id="cb19-24"><a href="#cb19-24"></a>        moving_var <span class="op">=</span> (<span class="fl">1.0</span> <span class="op">-</span> momentum) <span class="op">*</span> moving_var <span class="op">+</span> momentum <span class="op">*</span> var</span>
<span id="cb19-25"><a href="#cb19-25"></a>    Y <span class="op">=</span> gamma <span class="op">*</span> X_hat <span class="op">+</span> beta  <span class="co">## Scale and shift</span></span>
<span id="cb19-26"><a href="#cb19-26"></a>    <span class="cf">return</span> Y, moving_mean.data, moving_var.data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section class="slide level2">

<ul>
<li>We can now [<strong>create a proper <code>BatchNorm</code> layer.</strong>] Our layer will maintain proper parameters for scale <code>gamma</code> and shift <code>beta</code>, both of which will be updated in the course of training.</li>
<li>Additionally, our layer will maintain moving averages of the means and variances for subsequent use during model prediction.</li>
<li>Putting aside the algorithmic details, note the design pattern underlying our implementation of the layer.</li>
<li>Typically, we define the mathematics in a separate function, say <code>batch_norm</code>.</li>
<li>We then integrate this functionality into a custom layer, whose code mostly addresses bookkeeping matters, such as moving data to the right device context, allocating and initializing any required variables, keeping track of moving averages (here for mean and variance), and so on.</li>
<li>This pattern enables a clean separation of mathematics from boilerplate code.</li>
<li>Also note that for the sake of convenience we did not worry about automatically inferring the input shape here, thus we need to specify the number of features throughout.</li>
<li>By now all modern deep learning frameworks offer automatic detection of size and shape in the high-level batch normalization APIs (in practice we will use this instead).</li>
</ul>
</section>
<section class="slide level2">

<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">class</span> BatchNorm(nn.Module):</span>
<span id="cb20-2"><a href="#cb20-2"></a>    <span class="co">## num_features: the number of outputs for a fully connected layer or the</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="co">## number of output channels for a convolutional layer. num_dims: 2 for a</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="co">## fully connected layer and 4 for a convolutional layer</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_features, num_dims):</span>
<span id="cb20-6"><a href="#cb20-6"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb20-7"><a href="#cb20-7"></a>        <span class="cf">if</span> num_dims <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb20-8"><a href="#cb20-8"></a>            shape <span class="op">=</span> (<span class="dv">1</span>, num_features)</span>
<span id="cb20-9"><a href="#cb20-9"></a>        <span class="cf">else</span>:</span>
<span id="cb20-10"><a href="#cb20-10"></a>            shape <span class="op">=</span> (<span class="dv">1</span>, num_features, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb20-11"><a href="#cb20-11"></a>        <span class="co">## The scale parameter and the shift parameter (model parameters) are</span></span>
<span id="cb20-12"><a href="#cb20-12"></a>        <span class="co">## initialized to 1 and 0, respectively</span></span>
<span id="cb20-13"><a href="#cb20-13"></a>        <span class="va">self</span>.gamma <span class="op">=</span> nn.Parameter(torch.ones(shape))</span>
<span id="cb20-14"><a href="#cb20-14"></a>        <span class="va">self</span>.beta <span class="op">=</span> nn.Parameter(torch.zeros(shape))</span>
<span id="cb20-15"><a href="#cb20-15"></a>        <span class="co">## The variables that are not model parameters are initialized to 0 and</span></span>
<span id="cb20-16"><a href="#cb20-16"></a>        <span class="co">## 1</span></span>
<span id="cb20-17"><a href="#cb20-17"></a>        <span class="va">self</span>.moving_mean <span class="op">=</span> torch.zeros(shape)</span>
<span id="cb20-18"><a href="#cb20-18"></a>        <span class="va">self</span>.moving_var <span class="op">=</span> torch.ones(shape)</span>
<span id="cb20-19"><a href="#cb20-19"></a></span>
<span id="cb20-20"><a href="#cb20-20"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, X):</span>
<span id="cb20-21"><a href="#cb20-21"></a>        <span class="co">## If X is not on the main memory, copy moving_mean and moving_var to</span></span>
<span id="cb20-22"><a href="#cb20-22"></a>        <span class="co">## the device where X is located</span></span>
<span id="cb20-23"><a href="#cb20-23"></a>        <span class="cf">if</span> <span class="va">self</span>.moving_mean.device <span class="op">!=</span> X.device:</span>
<span id="cb20-24"><a href="#cb20-24"></a>            <span class="va">self</span>.moving_mean <span class="op">=</span> <span class="va">self</span>.moving_mean.to(X.device)</span>
<span id="cb20-25"><a href="#cb20-25"></a>            <span class="va">self</span>.moving_var <span class="op">=</span> <span class="va">self</span>.moving_var.to(X.device)</span>
<span id="cb20-26"><a href="#cb20-26"></a>        <span class="co">## Save the updated moving_mean and moving_var</span></span>
<span id="cb20-27"><a href="#cb20-27"></a>        Y, <span class="va">self</span>.moving_mean, <span class="va">self</span>.moving_var <span class="op">=</span> batch_norm(</span>
<span id="cb20-28"><a href="#cb20-28"></a>            X, <span class="va">self</span>.gamma, <span class="va">self</span>.beta, <span class="va">self</span>.moving_mean,</span>
<span id="cb20-29"><a href="#cb20-29"></a>            <span class="va">self</span>.moving_var, eps<span class="op">=</span><span class="fl">1e-5</span>, momentum<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb20-30"><a href="#cb20-30"></a>        <span class="cf">return</span> Y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>used <code>momentum</code> to govern the aggregation over past mean and variance estimates.</li>
<li>This is somewhat of a misnomer as it has nothing whatsoever to do with the <em>momentum</em> term of optimization in :numref:<code>sec_momentum</code>.</li>
<li>Nonetheless, it is the commonly adopted name for this term and in deference to API naming convention we use the same variable name in our code, too.</li>
</ul>
</section>
<section id="lenet-with-batch-normalization" class="slide level2">
<h2>[<strong>LeNet with Batch Normalization</strong>]</h2>
<ul>
<li>see how to apply <code>BatchNorm</code> in context, below we apply it to a traditional LeNet model (:numref:<code>sec_lenet</code>).</li>
<li>Recall that batch normalization is applied after the convolutional layers or fully connected layers but before the corresponding activation functions.</li>
</ul>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">class</span> BNLeNetScratch(d2l.Classifier):</span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, lr<span class="op">=</span><span class="fl">0.1</span>, num_classes<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb21-3"><a href="#cb21-3"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb21-4"><a href="#cb21-4"></a>        <span class="va">self</span>.save_hyperparameters()</span>
<span id="cb21-5"><a href="#cb21-5"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(</span>
<span id="cb21-6"><a href="#cb21-6"></a>            nn.LazyConv2d(<span class="dv">6</span>, kernel_size<span class="op">=</span><span class="dv">5</span>), BatchNorm(<span class="dv">6</span>, num_dims<span class="op">=</span><span class="dv">4</span>),</span>
<span id="cb21-7"><a href="#cb21-7"></a>            nn.Sigmoid(), nn.AvgPool2d(kernel_size<span class="op">=</span><span class="dv">2</span>, stride<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb21-8"><a href="#cb21-8"></a>            nn.LazyConv2d(<span class="dv">16</span>, kernel_size<span class="op">=</span><span class="dv">5</span>), BatchNorm(<span class="dv">16</span>, num_dims<span class="op">=</span><span class="dv">4</span>),</span>
<span id="cb21-9"><a href="#cb21-9"></a>            nn.Sigmoid(), nn.AvgPool2d(kernel_size<span class="op">=</span><span class="dv">2</span>, stride<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb21-10"><a href="#cb21-10"></a>            nn.Flatten(), nn.LazyLinear(<span class="dv">120</span>),</span>
<span id="cb21-11"><a href="#cb21-11"></a>            BatchNorm(<span class="dv">120</span>, num_dims<span class="op">=</span><span class="dv">2</span>), nn.Sigmoid(), nn.LazyLinear(<span class="dv">84</span>),</span>
<span id="cb21-12"><a href="#cb21-12"></a>            BatchNorm(<span class="dv">84</span>, num_dims<span class="op">=</span><span class="dv">2</span>), nn.Sigmoid(),</span>
<span id="cb21-13"><a href="#cb21-13"></a>            nn.LazyLinear(num_classes))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section class="slide level2">

<ul>
<li>As before, we will [<strong>train our network on the Fashion-MNIST dataset</strong>]. This code is virtually identical to that when we first trained LeNet.</li>
</ul>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>trainer <span class="op">=</span> d2l.Trainer(max_epochs<span class="op">=</span><span class="dv">10</span>, num_gpus<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-2"><a href="#cb22-2"></a>data <span class="op">=</span> d2l.FashionMNIST(batch_size<span class="op">=</span><span class="dv">128</span>)</span>
<span id="cb22-3"><a href="#cb22-3"></a>model <span class="op">=</span> BNLeNetScratch(lr<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb22-4"><a href="#cb22-4"></a>model.apply_init([<span class="bu">next</span>(<span class="bu">iter</span>(data.get_dataloader(<span class="va">True</span>)))[<span class="dv">0</span>]], d2l.init_cnn)</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="co"># trainer.fit(model, data)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Let’s [<strong>have a look at the scale parameter <code>gamma</code> and the shift parameter <code>beta</code></strong>] learned from the first batch normalization layer.</li>
</ul>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a>model.net[<span class="dv">1</span>].gamma.reshape((<span class="op">-</span><span class="dv">1</span>,)), model.net[<span class="dv">1</span>].beta.reshape((<span class="op">-</span><span class="dv">1</span>,))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>(tensor([1., 1., 1., 1., 1., 1.], grad_fn=&lt;ViewBackward0&gt;),
 tensor([0., 0., 0., 0., 0., 0.], grad_fn=&lt;ViewBackward0&gt;))</code></pre>
</div>
</div>
</section>
<section id="concise-implementation" class="slide level2">
<h2>[<strong>Concise Implementation</strong>]</h2>
<ul>
<li>Compared with the <code>BatchNorm</code> class, which we just defined ourselves, we can use the <code>BatchNorm</code> class defined in high-level APIs from the deep learning framework directly.</li>
<li>The code looks virtually identical to our implementation above, except that we no longer need to provide additional arguments for it to get the dimensions right.</li>
</ul>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">class</span> BNLeNet(d2l.Classifier):</span>
<span id="cb25-2"><a href="#cb25-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, lr<span class="op">=</span><span class="fl">0.1</span>, num_classes<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb25-3"><a href="#cb25-3"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb25-4"><a href="#cb25-4"></a>        <span class="va">self</span>.save_hyperparameters()</span>
<span id="cb25-5"><a href="#cb25-5"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(</span>
<span id="cb25-6"><a href="#cb25-6"></a>            nn.LazyConv2d(<span class="dv">6</span>, kernel_size<span class="op">=</span><span class="dv">5</span>), nn.LazyBatchNorm2d(),</span>
<span id="cb25-7"><a href="#cb25-7"></a>            nn.Sigmoid(), nn.AvgPool2d(kernel_size<span class="op">=</span><span class="dv">2</span>, stride<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb25-8"><a href="#cb25-8"></a>            nn.LazyConv2d(<span class="dv">16</span>, kernel_size<span class="op">=</span><span class="dv">5</span>), nn.LazyBatchNorm2d(),</span>
<span id="cb25-9"><a href="#cb25-9"></a>            nn.Sigmoid(), nn.AvgPool2d(kernel_size<span class="op">=</span><span class="dv">2</span>, stride<span class="op">=</span><span class="dv">2</span>),</span>
<span id="cb25-10"><a href="#cb25-10"></a>            nn.Flatten(), nn.LazyLinear(<span class="dv">120</span>), nn.LazyBatchNorm1d(),</span>
<span id="cb25-11"><a href="#cb25-11"></a>            nn.Sigmoid(), nn.LazyLinear(<span class="dv">84</span>), nn.LazyBatchNorm1d(),</span>
<span id="cb25-12"><a href="#cb25-12"></a>            nn.Sigmoid(), nn.LazyLinear(num_classes))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section class="slide level2">

<ul>
<li>Below, we [<strong>use the same hyperparameters to train our model.</strong>] Note that as usual, the high-level API variant runs much faster because its code has been compiled to C++ or CUDA while our custom implementation must be interpreted by Python.</li>
</ul>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a>trainer <span class="op">=</span> d2l.Trainer(max_epochs<span class="op">=</span><span class="dv">10</span>, num_gpus<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-2"><a href="#cb26-2"></a>data <span class="op">=</span> d2l.FashionMNIST(batch_size<span class="op">=</span><span class="dv">128</span>)</span>
<span id="cb26-3"><a href="#cb26-3"></a>model <span class="op">=</span> BNLeNet(lr<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb26-4"><a href="#cb26-4"></a>model.apply_init([<span class="bu">next</span>(<span class="bu">iter</span>(data.get_dataloader(<span class="va">True</span>)))[<span class="dv">0</span>]], d2l.init_cnn)</span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="co"># trainer.fit(model, data)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="discussion-1" class="slide level2">
<h2>Discussion</h2>
<ul>
<li>Intuitively, batch normalization is thought to make the optimization landscape smoother.</li>
<li>However, we must be careful to distinguish between speculative intuitions and true explanations for the phenomena that we observe when training deep models.</li>
<li>Recall that we do not even know why simpler deep neural networks (MLPs and conventional CNNs) generalize well in the first place.</li>
<li>Even with dropout and weight decay, they remain so flexible that their ability to generalize to unseen data likely needs significantly more refined learning-theoretic generalization guarantees.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>explanation for why it works:
<ul>
<li>by reducing <em>internal covariate shift</em>.</li>
<li>presumably by <em>internal covariate shift</em> the authors meant something like the intuition expressed above—the notion that the distribution of variable values changes over the course of training.</li>
</ul></li>
<li>However, there were two problems with this explanation:</li>
<li><ol type="i">
<li>This drift is very different from <em>covariate shift</em>, rendering the name a misnomer. If anything, it is closer to concept drift.</li>
</ol></li>
<li><ol start="2" type="i">
<li>The explanation offers an under-specified intuition but leaves the question of <em>why precisely this technique works</em> an open question wanting for a rigorous explanation.</li>
</ol></li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>Throughout this book, we aim to convey the intuitions that practitioners use to guide their development of deep neural networks.</li>
<li>However, we believe that it is important to separate these guiding intuitions from established scientific fact.</li>
<li>Eventually, when you master this material and start writing your own research papers you will want to be clear to delineate between technical claims and hunches.</li>
<li>Following the success of batch normalization, its explanation in terms of <em>internal covariate shift</em> has repeatedly surfaced in debates in the technical literature and broader discourse about how to present machine learning research.</li>
<li>In a memorable speech given while accepting a Test of Time Award at the 2017 NeurIPS conference, Ali Rahimi used <em>internal covariate shift</em> as a focal point in an argument likening the modern practice of deep learning to alchemy.</li>
<li>Subsequently, the example was revisited in detail in a position paper outlining troubling trends in machine learning :cite:<code>Lipton.Steinhardt.2018</code>.</li>
<li>Other authors have proposed alternative explanations for the success of batch normalization, some claiming that batch normalization’s success comes despite exhibiting behavior that is in some ways opposite to those claimed in the original paper :cite:<code>Santurkar.Tsipras.Ilyas.ea.2018</code>.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>We note that the <em>internal covariate shift</em> is no more worthy of criticism than any of thousands of similarly vague claims made every year in the technical machine learning literature.</li>
<li>Likely, its resonance as a focal point of these debates owes to its broad recognizability to the target audience.</li>
<li>Batch normalization has proven an indispensable method, applied in nearly all deployed image classifiers, earning the paper that introduced the technique tens of thousands of citations. We conjecture, though, that the guiding principles of regularization through noise injection, acceleration through rescaling and lastly preprocessing may well lead to further inventions of layers and techniques in the future.</li>
</ul>
</section>
<section class="slide level2">

<ul>
<li>On a more practical note, there are a number of aspects worth remembering about batch normalization:</li>
<li>During model training, batch normalization continuously adjusts the intermediate output of the network by utilizing the mean and standard deviation of the minibatch, so that the values of the intermediate output in each layer throughout the neural network are more stable.</li>
<li>Batch normalization for fully connected layers and convolutional layers are slightly different. In fact, for convolutional layers, layer normalization can sometimes be used as an alternative.</li>
<li>Like a dropout layer, batch normalization layers have different behaviors in training mode and prediction mode.</li>
<li>Batch normalization is useful for regularization and improving convergence in optimization. On the other hand, the original motivation of reducing internal covariate shift seems not to be a valid explanation.</li>
<li>For more robust models that are less sensitive to input perturbations, consider removing batch normalization :cite:<code>wang2022removing</code>.</li>
</ul>
</section>
<section id="exercises-3" class="slide level2">
<h2>Exercises</h2>
<ol type="1">
<li>Should we remove the bias parameter from the fully connected layer or the convolutional layer before the batch normalization? Why?</li>
<li>Compare the learning rates for LeNet with and without batch normalization.
<ol type="1">
<li>Plot the increase in validation accuracy.</li>
<li>How large can you make the learning rate before the optimization fails in both cases?</li>
</ol></li>
<li>Do we need batch normalization in every layer? Experiment with it?</li>
<li>Implement a “lite” version of batch normalization that only removes the mean, or alternatively one that only removes the variance. How does it behave?</li>
</ol>
</section>
<section class="slide level2">

<ol type="1">
<li>Fix the parameters <code>beta</code> and <code>gamma</code>. Observe and analyze the results.</li>
<li>Can you replace dropout by batch normalization? How does the behavior change?</li>
<li>Research ideas: think of other normalization transforms that you can apply:
<ol type="1">
<li>Can you apply the probability integral transform?</li>
<li>Can you use a full rank covariance estimate? Why should you probably not do that?</li>
<li>Can you use other compact matrix variants (block-diagonal, low-displacement rank, Monarch, etc.)?</li>
<li>Does a sparsification compression act as a regularizer?</li>
<li>Are there other projections (e.g., convex cone, symmetry group-specific transforms) that you can use?</li>
</ol></li>
</ol>
</section>
<section id="densely-connected-networks-densenet" class="slide level2">
<h2>Densely Connected Networks (DenseNet)</h2>
<ul>
<li><em>DenseNet</em> (dense convolutional network) is to some extent the logical extension of this cite:<code>Huang.Liu.Van-Der-Maaten.ea.2017</code>.</li>
<li>DenseNet is characterized by both the connectivity pattern where each layer connects to all the preceding layers and the concatenation operation (rather than the addition operator in ResNet) to preserve and reuse features from earlier layers.</li>
<li>To understand how to arrive at it, let’s take a small detour to mathematics.</li>
</ul>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="im">from</span> d2l <span class="im">import</span> torch <span class="im">as</span> d2l</span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="im">import</span> torch</span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="im">from</span> torch <span class="im">import</span> nn</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="from-resnet-to-densenet" class="slide level2">
<h2>From ResNet to DenseNet</h2>
<ul>
<li>Recall the Taylor expansion for functions. For the point <span class="math inline">\(x = 0\)</span> it can be written as</li>
</ul>
<p><span class="math display">\[f(x) = f(0) + x \cdot \left[f'(0) + x \cdot \left[\frac{f''(0)}{2!}  + x \cdot \left[\frac{f'''(0)}{3!}  + \ldots \right]\right]\right].\]</span></p>
<ul>
<li>The key point is that it decomposes a function into increasingly higher order terms. In a similar vein, ResNet decomposes functions into</li>
</ul>
<p><span class="math display">\[f(\mathbf{x}) = \mathbf{x} + g(\mathbf{x}).\]</span></p>
<ul>
<li>That is, ResNet decomposes <span class="math inline">\(f\)</span> into a simple linear term and a more complex nonlinear one.</li>
<li>What if we wanted to capture (not necessarily add) information beyond two terms? One such solution is DenseNet :cite:<code>Huang.Liu.Van-Der-Maaten.ea.2017</code>.</li>
</ul>
</section>
<section class="slide level2">

<p><img data-src="../img/densenet-block.svg" style="width:40.0%" data-background="white" alt="The main difference between ResNet (left) and DenseNet (right) in cross-layer connections: use of addition and use of concatenation."> <code>fig_densenet_block</code></p>
<ul>
<li>As shown in <code>fig_densenet_block</code>, the key difference between ResNet and DenseNet is that in the latter case outputs are <em>concatenated</em> (denoted by <span class="math inline">\([,]\)</span>) rather than added.</li>
<li>As a result, we perform a mapping from <span class="math inline">\(\mathbf{x}\)</span> to its values after applying an increasingly complex sequence of functions:</li>
</ul>
<p><span class="math display">\[\mathbf{x} \to \left[
\mathbf{x},
f_1(\mathbf{x}),
f_2\left(\left[\mathbf{x}, f_1\left(\mathbf{x}\right)\right]\right), f_3\left(\left[\mathbf{x}, f_1\left(\mathbf{x}\right), f_2\left(\left[\mathbf{x}, f_1\left(\mathbf{x}\right)\right]\right)\right]\right), \ldots\right].\]</span></p>
</section>
<section class="slide level2">

<ul>
<li>all these functions are combined in MLP to reduce the number of features again. In terms of implementation this is quite simple:</li>
<li>rather than adding terms, we concatenate them.</li>
<li>name DenseNet arises from the fact that the dependency graph between variables becomes quite dense.</li>
<li>last layer of such a chain is densely connected to all previous layers. The dense connections are shown in <code>fig_densenet</code>.</li>
</ul>
<p><img data-src="../img/densenet.svg" alt="Dense connections in DenseNet. Note how the dimensionality increases with depth."> :label:<code>fig_densenet</code></p>
</section>
<section class="slide level2">

<ul>
<li>main components that compose a DenseNet are <em>dense blocks</em> and <em>transition layers</em>. The former define how the inputs and outputs are concatenated, while the latter control the number of channels so that it is not too large, since the expansion <span class="math inline">\(\mathbf{x} \to \left[\mathbf{x}, f_1(\mathbf{x}), f_2\left(\left[\mathbf{x}, f_1\left(\mathbf{x}\right)\right]\right), \ldots \right]\)</span> can be quite high-dimensional.</li>
</ul>
</section>
<section id="dense-blocks" class="slide level2">
<h2>[<strong>Dense Blocks</strong>]</h2>
<ul>
<li>DenseNet uses the modified “batch normalization, activation, and convolution” structure of ResNet (see the exercise in :numref:<code>sec_resnet</code>). First, we implement this convolution block structure.</li>
</ul>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">def</span> conv_block(num_channels):</span>
<span id="cb28-2"><a href="#cb28-2"></a>    <span class="cf">return</span> nn.Sequential(</span>
<span id="cb28-3"><a href="#cb28-3"></a>        nn.LazyBatchNorm2d(), nn.ReLU(),</span>
<span id="cb28-4"><a href="#cb28-4"></a>        nn.LazyConv2d(num_channels, kernel_size<span class="op">=</span><span class="dv">3</span>, padding<span class="op">=</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li><em>dense block</em> consists of multiple convolution blocks, each using the same number of output channels. In the forward propagation, however, we concatenate the input and output of each convolution block on the channel dimension. Lazy evaluation allows us to adjust the dimensionality automatically.</li>
</ul>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">class</span> DenseBlock(nn.Module):</span>
<span id="cb29-2"><a href="#cb29-2"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_convs, num_channels):</span>
<span id="cb29-3"><a href="#cb29-3"></a>        <span class="bu">super</span>(DenseBlock, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb29-4"><a href="#cb29-4"></a>        layer <span class="op">=</span> []</span>
<span id="cb29-5"><a href="#cb29-5"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_convs):</span>
<span id="cb29-6"><a href="#cb29-6"></a>            layer.append(conv_block(num_channels))</span>
<span id="cb29-7"><a href="#cb29-7"></a>        <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(<span class="op">*</span>layer)</span>
<span id="cb29-8"><a href="#cb29-8"></a></span>
<span id="cb29-9"><a href="#cb29-9"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, X):</span>
<span id="cb29-10"><a href="#cb29-10"></a>        <span class="cf">for</span> blk <span class="kw">in</span> <span class="va">self</span>.net:</span>
<span id="cb29-11"><a href="#cb29-11"></a>            Y <span class="op">=</span> blk(X)</span>
<span id="cb29-12"><a href="#cb29-12"></a>            <span class="co">## Concatenate input and output of each block along the channels</span></span>
<span id="cb29-13"><a href="#cb29-13"></a>            X <span class="op">=</span> torch.cat((X, Y), dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb29-14"><a href="#cb29-14"></a>        <span class="cf">return</span> X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section class="slide level2">

<ul>
<li>In the following example, we [<strong>define a <code>DenseBlock</code> instance</strong>] with 2 convolution blocks of 10 output channels.</li>
<li>When using an input with 3 channels, we will get an output with <span class="math inline">\(3 + 10 + 10=23\)</span> channels. The number of convolution block channels controls the growth in the number of output channels relative to the number of input channels. This is also referred to as the <em>growth rate</em>.</li>
</ul>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1"></a>blk <span class="op">=</span> DenseBlock(<span class="dv">2</span>, <span class="dv">10</span>)</span>
<span id="cb30-2"><a href="#cb30-2"></a>X <span class="op">=</span> torch.randn(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">8</span>)</span>
<span id="cb30-3"><a href="#cb30-3"></a>Y <span class="op">=</span> blk(X)</span>
<span id="cb30-4"><a href="#cb30-4"></a>Y.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>torch.Size([4, 23, 8, 8])</code></pre>
</div>
</div>
</section>
<section id="transition-layers" class="slide level2">
<h2>[<strong>Transition Layers</strong>]</h2>
<ul>
<li>Since each dense block will increase the number of channels, adding too many of them will lead to an excessively complex model. A <em>transition layer</em> is used to control the complexity of the model. It reduces the number of channels by using an <span class="math inline">\(1\times 1\)</span> convolution. Moreover, it halves the height and width via average pooling with a stride of 2.</li>
</ul>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">def</span> transition_block(num_channels):</span>
<span id="cb32-2"><a href="#cb32-2"></a>    <span class="cf">return</span> nn.Sequential(</span>
<span id="cb32-3"><a href="#cb32-3"></a>        nn.LazyBatchNorm2d(), nn.ReLU(),</span>
<span id="cb32-4"><a href="#cb32-4"></a>        nn.LazyConv2d(num_channels, kernel_size<span class="op">=</span><span class="dv">1</span>),</span>
<span id="cb32-5"><a href="#cb32-5"></a>        nn.AvgPool2d(kernel_size<span class="op">=</span><span class="dv">2</span>, stride<span class="op">=</span><span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section class="slide level2">

<ul>
<li>[<strong>Apply a transition layer</strong>] with 10 channels to the output of the dense block in the previous example. This reduces the number of output channels to 10, and halves the height and width.</li>
</ul>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a>blk <span class="op">=</span> transition_block(<span class="dv">10</span>)</span>
<span id="cb33-2"><a href="#cb33-2"></a>blk(Y).shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>torch.Size([4, 10, 4, 4])</code></pre>
</div>
</div>
</section>
<section id="densenet-model" class="slide level2">
<h2>DenseNet Model</h2>
<ul>
<li>Next, we will construct a DenseNet model. DenseNet first uses the same single convolutional layer and max-pooling layer as in ResNet.</li>
</ul>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">class</span> DenseNet(d2l.Classifier):</span>
<span id="cb35-2"><a href="#cb35-2"></a>    <span class="kw">def</span> b1(<span class="va">self</span>):</span>
<span id="cb35-3"><a href="#cb35-3"></a>        <span class="cf">return</span> nn.Sequential(</span>
<span id="cb35-4"><a href="#cb35-4"></a>            nn.LazyConv2d(<span class="dv">64</span>, kernel_size<span class="op">=</span><span class="dv">7</span>, stride<span class="op">=</span><span class="dv">2</span>, padding<span class="op">=</span><span class="dv">3</span>),</span>
<span id="cb35-5"><a href="#cb35-5"></a>            nn.LazyBatchNorm2d(), nn.ReLU(),</span>
<span id="cb35-6"><a href="#cb35-6"></a>            nn.MaxPool2d(kernel_size<span class="op">=</span><span class="dv">3</span>, stride<span class="op">=</span><span class="dv">2</span>, padding<span class="op">=</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section class="slide level2">

<ul>
<li>Then, similar to the four modules made up of residual blocks that ResNet uses, DenseNet uses four dense blocks.</li>
<li>Similar to ResNet, we can set the number of convolutional layers used in each dense block. Here, we set it to 4, consistent with the ResNet-18 model in :numref:<code>sec_resnet</code>.</li>
<li>Furthermore, we set the number of channels (i.e., growth rate) for the convolutional layers in the dense block to 32, so 128 channels will be added to each dense block.</li>
<li>Similar to ResNet, a global pooling layer and a fully connected layer are connected at the end to produce the output.</li>
</ul>
</section>
<section class="slide level2">

<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1"></a><span class="at">@d2l.add_to_class</span>(DenseNet)</span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_channels<span class="op">=</span><span class="dv">64</span>, growth_rate<span class="op">=</span><span class="dv">32</span>, arch<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">4</span>),</span>
<span id="cb36-3"><a href="#cb36-3"></a>             lr<span class="op">=</span><span class="fl">0.1</span>, num_classes<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb36-4"><a href="#cb36-4"></a>    <span class="bu">super</span>(DenseNet, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb36-5"><a href="#cb36-5"></a>    <span class="va">self</span>.save_hyperparameters()</span>
<span id="cb36-6"><a href="#cb36-6"></a></span>
<span id="cb36-7"><a href="#cb36-7"></a></span>
<span id="cb36-8"><a href="#cb36-8"></a>    <span class="va">self</span>.net <span class="op">=</span> nn.Sequential(<span class="va">self</span>.b1())</span>
<span id="cb36-9"><a href="#cb36-9"></a>    <span class="cf">for</span> i, num_convs <span class="kw">in</span> <span class="bu">enumerate</span>(arch):</span>
<span id="cb36-10"><a href="#cb36-10"></a>        <span class="va">self</span>.net.add_module(<span class="ss">f'dense_blk</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>, DenseBlock(num_convs,</span>
<span id="cb36-11"><a href="#cb36-11"></a>                                                            growth_rate))</span>
<span id="cb36-12"><a href="#cb36-12"></a>        <span class="co">## The number of output channels in the previous dense block</span></span>
<span id="cb36-13"><a href="#cb36-13"></a>        num_channels <span class="op">+=</span> num_convs <span class="op">*</span> growth_rate</span>
<span id="cb36-14"><a href="#cb36-14"></a>        <span class="co">## A transition layer that halves the number of channels is added</span></span>
<span id="cb36-15"><a href="#cb36-15"></a>        <span class="co">## between the dense blocks</span></span>
<span id="cb36-16"><a href="#cb36-16"></a>        <span class="cf">if</span> i <span class="op">!=</span> <span class="bu">len</span>(arch) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb36-17"><a href="#cb36-17"></a>            num_channels <span class="op">//=</span> <span class="dv">2</span></span>
<span id="cb36-18"><a href="#cb36-18"></a>            <span class="va">self</span>.net.add_module(<span class="ss">f'tran_blk</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>, transition_block(</span>
<span id="cb36-19"><a href="#cb36-19"></a>                num_channels))</span>
<span id="cb36-20"><a href="#cb36-20"></a>    <span class="va">self</span>.net.add_module(<span class="st">'last'</span>, nn.Sequential(</span>
<span id="cb36-21"><a href="#cb36-21"></a>        nn.LazyBatchNorm2d(), nn.ReLU(),</span>
<span id="cb36-22"><a href="#cb36-22"></a>        nn.AdaptiveAvgPool2d((<span class="dv">1</span>, <span class="dv">1</span>)), nn.Flatten(),</span>
<span id="cb36-23"><a href="#cb36-23"></a>        nn.LazyLinear(num_classes)))</span>
<span id="cb36-24"><a href="#cb36-24"></a>    <span class="va">self</span>.net.<span class="bu">apply</span>(d2l.init_cnn)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="training-3" class="slide level2">
<h2>[<strong>Training</strong>]</h2>
<p>Since we are using a deeper network here, in this section, we will reduce the input height and width from 224 to 96 to simplify the computation.</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a>model <span class="op">=</span> DenseNet(lr<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb37-2"><a href="#cb37-2"></a>trainer <span class="op">=</span> d2l.Trainer(max_epochs<span class="op">=</span><span class="dv">10</span>, num_gpus<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-3"><a href="#cb37-3"></a>data <span class="op">=</span> d2l.FashionMNIST(batch_size<span class="op">=</span><span class="dv">128</span>, resize<span class="op">=</span>(<span class="dv">96</span>, <span class="dv">96</span>))</span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="co"># trainer.fit(model, data)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="summary-and-discussion" class="slide level2">
<h2>Summary and Discussion</h2>
<ul>
<li>main components that compose DenseNet are dense blocks and transition layers. For the latter, we need to keep the dimensionality under control when composing the network by adding transition layers that shrink the number of channels again.</li>
<li>In terms of cross-layer connections, unlike ResNet, where inputs and outputs are added together, DenseNet concatenates inputs and outputs on the channel dimension.</li>
<li>concat –&gt; heavy GPU memory consumption.</li>
</ul>
</section>
<section id="exercises-4" class="slide level2">
<h2>Exercises</h2>
<ol type="1">
<li>Why do we use average pooling rather than max-pooling in the transition layer?</li>
<li>One of the advantages mentioned in the DenseNet paper is that its model parameters are smaller than those of ResNet. Why is this the case?</li>
<li>One problem for which DenseNet has been criticized is its high memory consumption.
<ol type="1">
<li>Is this really the case? Try to change the input shape to <span class="math inline">\(224\times 224\)</span> to see the actual GPU memory consumption empirically.</li>
<li>Can you think of an alternative means of reducing the memory consumption? How would you need to change the framework?</li>
</ol></li>
<li>Implement the various DenseNet versions presented in Table 1 of the DenseNet paper :cite:<code>Huang.Liu.Van-Der-Maaten.ea.2017</code>.</li>
<li>Design an MLP-based model by applying the DenseNet idea. Apply it to the housing price prediction task in :numref:<code>sec_kaggle_house</code>.</li>
</ol>

<img src="eclipse_logo_small.png" class="slide-logo r-stretch"><div class="footer footer-default">
<p><a href="https://github.com/ECLIPSE-Lab/SS24_DataScienceForEM">SS24_DataScienceForEM</a></p>
</div>
</section>
    </div>
  </div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="04_convnets_1_files/libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="04_convnets_1_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="04_convnets_1_files/libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="04_convnets_1_files/libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="04_convnets_1_files/libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="04_convnets_1_files/libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="04_convnets_1_files/libs/revealjs/plugin/notes/notes.js"></script>
  <script src="04_convnets_1_files/libs/revealjs/plugin/search/search.js"></script>
  <script src="04_convnets_1_files/libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="04_convnets_1_files/libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'smaller': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1920,

        height: 1080,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
      tabsets.forEach(function(tabset) {
        const tabby = new Tabby('#' + tabset.id);
      });
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button', {
        text: function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
      });
      clipboard.on('success', function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      });
      function tippyHover(el, contentFn) {
        const config = {
          allowHTML: true,
          content: contentFn,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.closest('section.slide') || el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start'
        };
          config['offset'] = [0,0];
          config['maxWidth'] = 700;
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          return note.innerHTML;
        });
      }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    

</body></html>